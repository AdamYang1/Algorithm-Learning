\documentclass[openany]{article}

%Typesetting and language
\usepackage[american]{babel}
\usepackage[T1]{fontenc}
\usepackage{charter}
\usepackage{enumitem}
\usepackage{hyperref}

%Symbols
\usepackage{amssymb, amsmath, amsthm, bm}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{marvosym}
\usepackage{MnSymbol}

%Colors & graphics
\usepackage[dvipsnames]{xcolor}
\usepackage{pgfplots}
\usepackage[numbered,framed]{matlab-prettifier}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\usepackage[object=vectorian]{pgfornament}
\usepackage{wrapfig}
\usepackage{varwidth}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{caption}
\usepackage{float}
\usepackage{geometry}
\usepackage{ulem}
\usepackage[most]{tcolorbox}
\usepackage{array}

\setlength{\parindent}{0pt}

\makeatletter
\g@addto@macro\bfseries{\boldmath}
\makeatother


\renewcommand{\Re}{\mathfrak{Re}}
\renewcommand{\Im}{\mathfrak{Im}}

\geometry{left=2cm,right=2cm,bottom=2cm,top=2cm}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\sectionmark}[1]{\markright{\arabic{section} - #1}}
\cfoot{\thepage}
\lhead{CS270}
\chead{HW7}
\rhead{Adam Yang}
\renewcommand{\headrulewidth}{1pt}


\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Fix}{Fix}
\DeclareMathOperator{\Stab}{Stab}
\DeclareMathOperator{\cov}{cov}
\DeclareMathOperator*{\esssup}{ess\,sup}
\DeclareMathOperator{\corr}{corr}
\DeclareMathOperator{\lik}{lik}
\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax}

\newcommand{\niceline}[2]{%
		\nointerlineskip \vspace{.5\baselineskip}\hspace{\fill}
		{\color{#1}
				\resizebox{0.5\linewidth}{2ex}
				{{%
								{\begin{tikzpicture}
										\node  (C) at (0,0) {};
										\node (D) at (9,0) {};
										\path (C) to [ornament=#2] (D);
										\end{tikzpicture}}}}}%
		\hspace{\fill}
		\par\nointerlineskip \vspace{.5\baselineskip}
}

\definecolor{darkViolet}{HTML}{9400D3}
\newcommand{\sweetline}{%
		\noindent
		\begin{center}
				{\color{darkViolet}
						\resizebox{0.5\linewidth}{1ex}
						{{%
										{\begin{tikzpicture}
												\node  (C) at (0,0) {};
												\node (D) at (9,0) {};
												\path (C) to [ornament=85] (D);
												\end{tikzpicture}}}}}%
		\end{center}
}

\definecolor{remarkPurple}{HTML}{8346FF}
\definecolor{defBlue}{HTML}{0673FF}
\definecolor{exPurple}{HTML}{FF8710}

%THEOREM
\newtcbtheorem[auto counter,number within=section]{theorem}{Theorem}%
{enhanced,colback=white, breakable,frame empty,interior empty,colframe=cyan!50!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=cyan!15!white,
				borderline={0.5mm}{0mm}{cyan!15!white},
				borderline={0.5mm}{0mm}{cyan!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{thm}

%PROPOSITION
\newtcbtheorem[use counter from=theorem]{proposition}{Proposition}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prop}

%DEFINITION
\newtcbtheorem[use counter from=theorem]{definition}{Definition}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{def}

%COROLLARY
\newtcbtheorem[use counter from=theorem]{corollary}{Corollary}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{cor}

%REMARK
\newtcbtheorem[no counter]{remark}{Remark}%
{detach title, colback=white,enhanced ,breakable,frame empty, interior empty, fonttitle=\bfseries, coltitle=Violet, before upper={\tcbtitle.\quad},
				borderline west={0.5mm}{0mm}{remarkPurple!40!white},
				borderline west={0.5mm}{0mm}{remarkPurple!60!white,dashed}}{remark}

%LEMMA
\makeatletter
\newtcbtheorem[number within = tcb@cnt@theorem]{lemma}{Lemma}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=orange!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=orange!20!white,
				borderline={0.5mm}{0mm}{orange!20!white},
				borderline={0.5mm}{0mm}{orange!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{lemma}
\makeatother


%PROOF
%%{enhanced,breakable,frame empty,interior empty,colframe=remarkPurple!75!white, top=8mm,
%	coltitle=black,fonttitle=\bfseries,colbacktitle=remarkPurple!20!white,
%	borderline={0.5mm}{0mm}{remarkPurple!20!white},
%	borderline={0.5mm}{0mm}{remarkPurple!50!white,dashed},
%	attach boxed title to top left={yshift=-4mm},
%	boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prf}


\tcolorboxenvironment{proof}{% amsthm' 
				blanker,breakable,left=5mm,
				before skip=10pt,after skip=10pt,
				borderline west={0.5mm}{0pt}{cyan!40},
				borderline west={0.5mm}{0pt}{remarkPurple!10, dashed}}

%PROBLEM
\newtcbtheorem[auto counter]{problem}{Problem}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=cyan!50!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=cyan!20!white,
				borderline={0.5mm}{0mm}{cyan!20!white},
				borderline={0.5mm}{0mm}{cyan!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prob}

%EXAMPLE
%\newtcbtheorem[use counter from=problem]{example}{Example}%
%{enhanced,breakable,colback=white,frame empty,interior empty,colframe=remarkPurple!50!white, top=8mm,
%		coltitle=black,fonttitle=\bfseries,colbacktitle=remarkPurple!30!white,
%		borderline={0.5mm}{0mm}{remarkPurple!30!white},
%		borderline={0.5mm}{0mm}{remarkPurple!30!white,dashed},
%		attach boxed title to top left={yshift=-4mm},
%		boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{ex}


\newtcbtheorem[use counter from=theorem]{example}{Example}%
{detach title, colback=white,enhanced ,breakable,frame empty, interior empty, fonttitle=\bfseries, coltitle=black, before upper={\tcbtitle.\quad},
		borderline west={0.5mm}{0mm}{remarkPurple!30!white},
		borderline ={0.5mm}{0mm}{remarkPurple!30!white}}{example}

%SOLUTION
\newtcbtheorem[no counter]{solution}{Solution}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=green!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=green!20!white,
				borderline={0.5mm}{0mm}{green!20!white},
				borderline={0.5mm}{0mm}{green!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{sol}
\definecolor{realPurple}{HTML}{AA05F9}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
				style=Matlab-editor,
				language=C,
				aboveskip=3mm,
				belowskip=3mm,
				xleftmargin=3mm,
				showstringspaces=false,
				columns=flexible,
				frame=none,
				basicstyle={\small\ttfamily},
				numberstyle=\tiny\color{gray},
				keywordstyle=\color{blue},
				commentstyle=\color{dkgreen},
				stringstyle=\color{mauve},
				breaklines=true,
				breakatwhitespace=true,
				mlshowsectionrules = true,
				tabsize=3,
                    escapechar = ~,
				backgroundcolor=\color{cyan!5}
}

\newcommand\mmybox[2][fill=cyan!20]{%
    \tikz[baseline]\node[%
        inner ysep=0pt, 
        inner xsep=2pt, 
        anchor=text, 
        rectangle, 
        rounded corners=1mm,
        #1] {\strut#2};%
}


\def\changemargin#1#2{\list{}{\rightmargin#2\leftmargin#1}\item[]}
\let\endchangemargin=\endlist

\linespread{1.4}



% MAIN DOC
\begin{document}

\title{HW 7}
\author{Adam Yang}
% \date{\today}
\maketitle




\section*{Problem1}

In Problem 1, we are given a graph $G=(V,E)$, each node $e\in E$ has non-negative capacities $c_e$, a source node $s$ which has no edge flows into, and a sink node $t$ which has no edge flows out, and a flow $f$ and value $\nu(f)$.

\subsection*{Algorithm}
\begin{proof}[Algorithm]{}
		\renewcommand{\qedsymbol}{}
		An Algorithm to output a new flow $f'$ with $f'_e \leq f_e$ for all edges $e$, of the same value $\nu(f') = \nu(f)$, and such that $f'$ is acyclic.
		\begin{lstlisting}[basicstyle=\fontsize{8}{9}\selectfont\ttfamily]
/**
* This is a helper function similar to DFS to help find the cycle in graph
* it takes input graph G and a start node s
* this algorithm is mostly similar to the one in cs104 slides, using white to denote unexplored node, gray to denote the node that are still waiting to explore, and black to denote the node that has been fully explored (every outflow path from that node has been explored)
* parent attribute is for finding cycle path
**/
def helper(graph G, Node s): // start from s because s is not in any cycle
    s.color = GRAY
    for each outflow vertex v in Adj(s) do // Adj(s) returns a list of adjacent nodes for s
        List<Node> res;
        if v.color == WHITE then
            v.parent = s
            res = helper(G, v)
            if res != null then return res // stop recursing once we find a cycle
            // if res is still null, this means there is no cycle on s to current v path, then switch to next v to find cycle
        else if v.color == GRAY then // we find a cycle! since v has been reached 
            Node temp = s
            res.append(v)
            while temp != v do //backtrace to find the cycle path
                res.append(temp)
                temp = temp.parent
            return res;
        else return NULL; //color == BLACK
    s.color = BLACK // either current node s has no more outflow edges or all the outflow path from s don't contain a cycle, we set it to BLACK to denote fully explored
    return res; // if we reach here, it means any outflow path from s contains no cycle and res stays NULL
    
/**
* with the helper defined above, we can find the cycle on any outflow path from s if there is one
* now start our algorithm
**/
~$f':=$~ the new flow that we will output
~$f' = f$~ at the beginning
initialize all nodes in graph to WHITE // for dfs helper
List<Node> cycle = helper(G,s)
while cycle == NULL:
    define any cycle found as ~$C \subseteq E_{exists}$~
    for all edges ~$e$~ included in cycle: //we store list of Node but the edge can be easily found in O(1)
        let ~$\varepsilon = \mathbf{\min}(f(e))$~, ~$\forall e\in C$~
        subtract ~$\varepsilon$~ from the flow of all edge in ~$C$~ on instance ~$f'$~
        ~$\forall e$~ in ~$C:$~ ~$f'(e)=0$~, delete e from the graph
    set all nodes in graph to WHITE // for next iteration helper
return new flow ~$f'$~
		\end{lstlisting} 
\end{proof}

\textbf{Observations:}

1. source node $s$ and sank node $t$ cannot be involved in any cycle because they all only have one-way edges.

2. $f$ is a valid flow that satisfies Conservation, Capacity, Non-negativity properties

\subsection*{Proof}
Let's first assume the helper function actually works, we will prove its correctness later. We now prove the algorithm returns a correct result if helper function works. In the following proof, we focus on a single cycle $C$ which could be any cycles, $\varepsilon$ is the smallest flow in the cycle, $E_{exists}$ is the existing or "non-deleted" edges.

To prove that $f'$ is a valid flow:

\begin{proof}[1]{Conservation}

Focus on a cycle $C \subseteq E_{exists}$, $C$ has a set of node $\{v_1, v_2, ..., v_k\}, 1 < k \leq n$. Define the $e_{i,in} \in C$ for $v_i$ as the in-flow edge, $e_{i,out} \in C$ as the out-flow edge in the cycle. Define $s_{i,in} \notin C$ as the in-flow edge for $v_i$ that is not in cycle and $s_{i,out} \notin C$ as the out-flow edge for $v_i$ that is not in cycle. Define $f_{in}(v_i)$ and $f_{out}(v_i)$ as the total in-flow and out-flow for $v_i$.

In the algorithm, we find smallest flow $\varepsilon$ from all the $f(e), e\in C$ and then subtract all edge in $C$ with $\varepsilon$.

Before subtraction, \[\forall v_i \in \{v_1, ..., v_k\}: f_{in}(v_i) = f(e_{i,in}) + \sum_{s_{i,in}} f(s_{i,in}) = f_{out}(v_i) = f(e_{i,out})+\sum_{s_{i,out}} f(s_{i,out}) \]

Since the assignment in algorithm doesn't impact the edge not in cycle, therefore $\sum_{s_{i,in}} f(s_{i,in}) = \sum_{s_{i,out}} f(s_{i,out})$. Therefore, the in-flow and out-flow doesn't change for $v_i$:

\[f_{in}(v_i) - \varepsilon = f(e_{i,in}) + \sum_{s_{i,in}} f(s_{i,in}) - \varepsilon = f(e_{i,out}) +\sum_{s_{i,out}} f(s_{i,out}) - \varepsilon = f_{out}(v_i) - \varepsilon\]

Therefore, every node in any $C$ is still conservative. Thus, for graph $G$, conservation holds.


\end{proof}

\begin{proof}[2]{To prove capacity doesn't exceed}
    \[f'(e) = f(e) - \varepsilon \leq f(e) \leq c(e)\] because $f$ is a valid flow and $f(e)$ subtract some non-negative value.
    
\end{proof}

\begin{proof}[3]{To prove each flow is non-negative}
    \[f'(e) = f(e) - \varepsilon \geq 0\] because $\varepsilon = \mathbf{\min}(f(e))$ and thus $\varepsilon \leq f(e)$, $\forall e \in C$. This can also show that $f'(e)\leq f(e) \forall e \in G$ since we subtract some non-negative value from $f(e)$.
    
\end{proof}

Therefore, $f'$ is a valid flow. Since $s$ and $t$ are not included in any cycle, the sum of out-flow for $s$ doesn't change since no subtraction happens on these edges. Similarly, the sum of in-flow for $t$ doesn't change. Also, as conservation holds for all nodes included in cycles.
\[\nu(f') = \nu(f)\]

\begin{proof}[4]{To the algorithm terminates and output an acyclic graph}

Because in each iteration, we strictly "delete" at least an edge to remove a cycle. Meanwhile, $G$ only has finite amount of cycle. Therefore, we at most delete all the edge in the graph and will finally remove all the cycle, which leads to the end of termination.


\end{proof}

Now, let's prove the correctness of helper function using contradiction.
\begin{proof}[5]{To prove the helper function actually works}

Correct statement: if there is still a cycle, we return it in a list. if no more cycle, then we return null

Observing the algorithm, we detect a cycle whenever a node $u$ visit a GRAY node $v$, $u\neq v, u,v \in V$. This means that $v$ has already been encountered once during helper function recursion before and $u->v$ will lead us back to $v$ at some point. Thus, a cycle is detected and we can say that $v$ it the start node of the cycle, $u$ is the last node of the cycle. Now, we will start finding the cycle through backtracing. We are currently on node $u$ and add $u$ to the list. By going back to $u$.parent until we reach $v$, we capture the whole cycle as the graph show.

Although it is possible for a node to have multiple parents in a graph, we will update the parent of a node for a specific path. So it won't impact the helper function.

\end{proof}
\begin{figure}[htp]
    \centering
    \includegraphics[width=5cm]{WX20221104-180416@2x.png}
    \caption{G=(V,E)}
    \label{fig:galaxy}
\end{figure}
Now that the helper is correct and our algorithm also outputs a correct $f'$, this concludes the proof. $\square$

\subsection*{Running Time}
Define $|E| = m$, $|V| = n$.

First let's take a look at the helper function. Since it's a DFS-like function, and indeed it at most visit all the edge and all the nodes. Since the length of cycle is also at most $m$, it takes $\mathcal{O}(m+n)$.

Notice that we at least delete one edge to remove one cycle in each iteration, and we only have finite amount of cycles in $G$, the iteration at most repeats $\mathcal{O}(m)$ times. Since each helper is $\mathcal{O}(m+n)$ and subtracting $\varepsilon$ takes up to $\mathcal{O}(m)$ and set all node back to WHITE takes at most $\mathcal{O}(n)$, line 35 to 41 takes $\sum_{m\in E}\mathcal{O}(m+n) = \mathcal{O}(m(m+n))$.
Therefore, the total running time is 
\[T(n) = \mathcal{O}(m^2+mn)\]

\section*{Problem2}
In Problem 2, $m$ denotes the number of drivers, $n$ denotes the number of consumers. For each consumer $i$, we have their location $L_i$, the location of restaurant where they order $R_i$, and the time that they are willing to wait $t_i$. For each drive $j$, we have their locations $D_j$. For the whole problem, $i \in \{1,2,...,n\}$ and $j \in \{1,2,...,m\}$

Notice that we are able to find out the time for a driver $j$ to arrive consumer $i$'s address by calculating the time by adding the total commuting time taken from $D_j -> R_i -> L_i $ with $1$ minute of waiting. Therefore, for each driver $j$, we are able to filter out all the customer that they will arrive late. Denote the time running from one place to another place as $t(S,T)$, where $S$ is the starting location and $T$ is the ending location.
\subsection*{Algorithm}
\begin{proof}[Algorithm]{}
		\renewcommand{\qedsymbol}{}
		An Algorithm to output both the profit and the assignment of drivers to orders that gives that profit
		\begin{lstlisting}[basicstyle=\fontsize{8}{9}\selectfont\ttfamily]
~$t(S,T)$~ := the time it takes to get ~$T$~ from ~$S$~ ~$\forall$~ driver
~$G(V,E)$~ := a directed graph, ~$V$~ contains all ~$m$~ drivers and ~$n$~ customers, a source node ~$s$~, and a sank node ~$t$~, each driver and each customer is a unique node
~$d_j$~ := driver ~$j$~ node in ~$G$~
~$c_i$~ := customer ~$i$~ node in ~$G$~

~$\forall d_j$~ build an edge from ~$s$~ to ~$d_j$~ with capacity of 1
~$\forall c_i$~, build an edge from ~$c_i$~ to ~$t$~ with capacity of 1

~$M$~ := the matching that we want to output, it contains all the drivers and all customers nodes

for each driver ~$d_j$~:
    for each customer ~$c_i$~:
        if ~$t(D_j, R_i) + t(R_i, L_i) + 1 \leq t_i$~
            build an edge from driver ~$d_j$~ to customer ~$c_i$~ with capacity of ~$\infty$~

Implement Edmond-Karp algorithm on ~$G$~ and find the max flow ~$f$~

// to get the assignment
for each driver ~$d_j$~:
    for each customer ~$c_i$~:
        if ~$f(e(d_j, c_i)) == 1$~
            build an edge from $d_j$ to $c_i$ in ~$M$~
// *10 because each on-time delivery we get 10 $
return ~$\nu(f)$~*10 and ~$M$~
        
		\end{lstlisting} 
\end{proof}

In the algorithm, we build a graph $G$ like the following, $c(e(s,d_j)) = 1, j=1,2,...,m$; $c(e(c_i,t)) = 1, i = 1,2,...,n$; and $\exists e(d_j, c_i), c(e(d_j,c_i)) = \infty$ if $t(D_j,R_i)+t(R_i,L_i)+1 \leq t_i$
\begin{figure}[htp]
    \centering
    \includegraphics[width=10cm]{1.png}
    \caption{G=(V,E)}
    \label{fig:galaxy}
\end{figure}

\subsection*{Proof}
\begin{proof}[Correctness]{}
    Since Edmond-Karp can always finds the max-cardinality for a bipartite graph, we need to show that we can reduce our problem into a bipartite matching problem. 

    First, let's prove that the algorithm is finding max-flow on a valid bipartite graph. Let's take a look at drivers and customers only, ignoring $s$ and $t$ and out-flow edges from $s$ and in-flow edges to $t$, each driver $d_j$ only has edges goes to customers. For any two drivers $d_{j_1}, d_{j_2}, j_1 \neq j_2$, $e(d_{j_1}, d_{j_2})$ and $e(d_{j_2}, d_{j_1})$ don't exist. Similarly, for any two customers $c_{i_1}, c_{i_2}, i_1 \neq i_2$, $e(c_{i_1}, c_{i_2})$ and $e(c_{i_2}, c_{i_1})$ don't exist. Therefore, the graph $G$ ignoring $s$ and $t$ and the edges that out-flow from $s$ and in-flow to $t$ is a valid bipartite graph. Now we consider source $s$ and sank $t$ and related edges, our algorithm uses Edmond-Karp to find the max bipartite matching between drivers and customers as discussed in lecture.

    Second, let's prove that we can reduce our problem to a bipartite maximum matching problem. Observing the algorithm, we only add an edge from a drive $d_j$ to a $c_i$ when the time for $d_j$ to drive from their current location $D_j$ to the restaurant $R_i$, wait for one minute to pick up, and drive from $R_i$ to $L_i$ is no more than $t_i$. This means that each $e(d_j, c_i)$ is a valid edge that can bring the company \$10 profit. In order to maximize the profit, we want to send as many drivers to send a valid delivery as possible. According to the prompt, we can at most assign a driver with 1 order, we can say each driver is at most matched with one consumer in the assignment. Therefore, the more can match driver to customer, the more profits the company gains. This means that our problem now becomes the max bipartite matching where we find the maximum matching for the $G$ excluding $s$, $t$ and relevant edges. By setting all the outflow edges from $s$ with capacity 1, all the inflow edges to $t$ with capacity 1, and all profitable edges from $d_j$ to $c_i$ with capacity, we have the same setup as solving maximum bipartite matching as discussed in lecture. \textbf{As proved in lecture,} Edmond-karp is able to find the max flow for a graph for $G$ and thus find a max flow $f$. This helps us build a max bipartite matching $M$ if we only picks $d_j -> c_i$ where $f(e(d_j,c_i) = 1$, where $|M| = \nu(f).$ By multiplying $\nu(f)$ with 10, we have correct maximum profits. By picking $e(d_j,c_i)$ S.T. $f(e(d_j,c_i) = 1$, excludes $s$, $t$, and outflow edges from $s$ and inflow edges to $t$, we return a correct assignment that output $f$ and maximizes the profit.
\end{proof}

\subsection*{Running Time}
From line 1 to line 7, the assignment is all $\mathcal{O}(1)$. On line 9, it takes $\mathcal{O}(+n+1+1)$ to build the basic $M$. From line 11 to 14, we loop through all $m$ drivers and $n$ customers, and construct an edge in $\mathcal{O}(1)$, thus line 11 to 14 we have $\sum_{j=1}^{j=m}\sum_{i=1}^{i=n}\mathcal{O}(1) = \mathcal{O}(mn)$. As discussed in lecture, Edmond-Karp has run-time $\mathcal{O}(mn(m+n))$. Therefore, the total runtime is
\[T(n) = \mathcal{O}(m+n) + \mathcal{O}(mn) + \mathcal{O}(mn(m+n)) = \mathcal{O}(m^2n+n^2m)\]

\end{document}
