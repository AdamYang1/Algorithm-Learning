\documentclass[openany]{article}

%Typesetting and language
\usepackage[american]{babel}
\usepackage[T1]{fontenc}
\usepackage{charter}
\usepackage{enumitem}
\usepackage{hyperref}

%Symbols
\usepackage{amssymb, amsmath, amsthm, bm}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{marvosym}
\usepackage{MnSymbol}

%Colors & graphics
\usepackage[dvipsnames]{xcolor}
\usepackage{pgfplots}
\usepackage[numbered,framed]{matlab-prettifier}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\usepackage[object=vectorian]{pgfornament}
\usepackage{wrapfig}
\usepackage{varwidth}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{caption}
\usepackage{float}
\usepackage{geometry}
\usepackage{ulem}
\usepackage[most]{tcolorbox}
\usepackage{array}

\setlength{\parindent}{0pt}

\makeatletter
\g@addto@macro\bfseries{\boldmath}
\makeatother


\renewcommand{\Re}{\mathfrak{Re}}
\renewcommand{\Im}{\mathfrak{Im}}

\geometry{left=2cm,right=2cm,bottom=2cm,top=2cm}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\sectionmark}[1]{\markright{\arabic{section} - #1}}
\cfoot{\thepage}
\lhead{Algo Learning}
\chead{Dynamic Programming}
\rhead{Adam Yang}
\renewcommand{\headrulewidth}{1pt}


\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Fix}{Fix}
\DeclareMathOperator{\Stab}{Stab}
\DeclareMathOperator{\cov}{cov}
\DeclareMathOperator*{\esssup}{ess\,sup}
\DeclareMathOperator{\corr}{corr}
\DeclareMathOperator{\lik}{lik}
\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax}

\newcommand{\niceline}[2]{%
		\nointerlineskip \vspace{.5\baselineskip}\hspace{\fill}
		{\color{#1}
				\resizebox{0.5\linewidth}{2ex}
				{{%
								{\begin{tikzpicture}
										\node  (C) at (0,0) {};
										\node (D) at (9,0) {};
										\path (C) to [ornament=#2] (D);
										\end{tikzpicture}}}}}%
		\hspace{\fill}
		\par\nointerlineskip \vspace{.5\baselineskip}
}

\definecolor{darkViolet}{HTML}{9400D3}
\newcommand{\sweetline}{%
		\noindent
		\begin{center}
				{\color{darkViolet}
						\resizebox{0.5\linewidth}{1ex}
						{{%
										{\begin{tikzpicture}
												\node  (C) at (0,0) {};
												\node (D) at (9,0) {};
												\path (C) to [ornament=85] (D);
												\end{tikzpicture}}}}}%
		\end{center}
}

\definecolor{remarkPurple}{HTML}{8346FF}
\definecolor{defBlue}{HTML}{0673FF}
\definecolor{exPurple}{HTML}{FF8710}

%THEOREM
\newtcbtheorem[auto counter,number within=section]{theorem}{Theorem}%
{enhanced,colback=white, breakable,frame empty,interior empty,colframe=cyan!50!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=cyan!15!white,
				borderline={0.5mm}{0mm}{cyan!15!white},
				borderline={0.5mm}{0mm}{cyan!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{thm}

%PROPOSITION
\newtcbtheorem[use counter from=theorem]{proposition}{Proposition}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prop}

%DEFINITION
\newtcbtheorem[use counter from=theorem]{definition}{Definition}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{def}

%COROLLARY
\newtcbtheorem[use counter from=theorem]{corollary}{Corollary}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{cor}

%REMARK
\newtcbtheorem[no counter]{remark}{Remark}%
{detach title, colback=white,enhanced ,breakable,frame empty, interior empty, fonttitle=\bfseries, coltitle=Violet, before upper={\tcbtitle.\quad},
				borderline west={0.5mm}{0mm}{remarkPurple!40!white},
				borderline west={0.5mm}{0mm}{remarkPurple!60!white,dashed}}{remark}

%LEMMA
\makeatletter
\newtcbtheorem[number within = tcb@cnt@theorem]{lemma}{Lemma}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=orange!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=orange!20!white,
				borderline={0.5mm}{0mm}{orange!20!white},
				borderline={0.5mm}{0mm}{orange!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{lemma}
\makeatother


%PROOF
%%{enhanced,breakable,frame empty,interior empty,colframe=remarkPurple!75!white, top=8mm,
%	coltitle=black,fonttitle=\bfseries,colbacktitle=remarkPurple!20!white,
%	borderline={0.5mm}{0mm}{remarkPurple!20!white},
%	borderline={0.5mm}{0mm}{remarkPurple!50!white,dashed},
%	attach boxed title to top left={yshift=-4mm},
%	boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prf}


\tcolorboxenvironment{proof}{% amsthm' 
				blanker,breakable,left=5mm,
				before skip=10pt,after skip=10pt,
				borderline west={0.5mm}{0pt}{cyan!40},
				borderline west={0.5mm}{0pt}{remarkPurple!10, dashed}}

%PROBLEM
\newtcbtheorem[auto counter]{problem}{Problem}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=cyan!50!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=cyan!20!white,
				borderline={0.5mm}{0mm}{cyan!20!white},
				borderline={0.5mm}{0mm}{cyan!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prob}

%EXAMPLE
%\newtcbtheorem[use counter from=problem]{example}{Example}%
%{enhanced,breakable,colback=white,frame empty,interior empty,colframe=remarkPurple!50!white, top=8mm,
%		coltitle=black,fonttitle=\bfseries,colbacktitle=remarkPurple!30!white,
%		borderline={0.5mm}{0mm}{remarkPurple!30!white},
%		borderline={0.5mm}{0mm}{remarkPurple!30!white,dashed},
%		attach boxed title to top left={yshift=-4mm},
%		boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{ex}


\newtcbtheorem[use counter from=theorem]{example}{Example}%
{detach title, colback=white,enhanced ,breakable,frame empty, interior empty, fonttitle=\bfseries, coltitle=black, before upper={\tcbtitle.\quad},
		borderline west={0.5mm}{0mm}{remarkPurple!30!white},
		borderline ={0.5mm}{0mm}{remarkPurple!30!white}}{example}

%SOLUTION
\newtcbtheorem[no counter]{solution}{Solution}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=green!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=green!20!white,
				borderline={0.5mm}{0mm}{green!20!white},
				borderline={0.5mm}{0mm}{green!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{sol}
\definecolor{realPurple}{HTML}{AA05F9}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
				style=Matlab-editor,
				language=C,
				aboveskip=3mm,
				belowskip=3mm,
				xleftmargin=3mm,
				showstringspaces=false,
				columns=flexible,
				frame=none,
				basicstyle={\small\ttfamily},
				numberstyle=\tiny\color{gray},
				keywordstyle=\color{blue},
				commentstyle=\color{dkgreen},
				stringstyle=\color{mauve},
				breaklines=true,
				breakatwhitespace=true,
				mlshowsectionrules = true,
				tabsize=3,
				backgroundcolor=\color{cyan!5}
}

\newcommand\mmybox[2][fill=cyan!20]{%
    \tikz[baseline]\node[%
        inner ysep=0pt, 
        inner xsep=2pt, 
        anchor=text, 
        rectangle, 
        rounded corners=1mm,
        #1] {\strut#2};%
}


\def\changemargin#1#2{\list{}{\rightmargin#2\leftmargin#1}\item[]}
\let\endchangemargin=\endlist

\linespread{1.4}



% MAIN DOC
\begin{document}

\title{Dynamic Programming}
\author{Adam Yang}
% \date{\today}
\maketitle




\section*{Problem1}

\subsection*{Algorithm}
\begin{proof}[Algorithm]{}
		\renewcommand{\qedsymbol}{}
		An Algorithm to calculate the sequence of die rolls gets to winning square as quickly as possible.
		\begin{lstlisting}[basicstyle=\fontsize{8}{9}\selectfont\ttfamily]
// this is a pseudo-code, for convenience we define add_square() for vector<T> similar to push_back() in C++. It returns an original list added with a new square at the end and won't impact original list
// push_back() is simply C++ push_back() method for vector<T>
vector<int> findSeq( int[] d )
{
    // define infinity as the largest number we can get
    // won't use INT_MAX for convenience (overflowing issue)
    // here we denote the size of d[] as n
    // Will explain the variables used in algorithm later
    // if i is a ladder, d[i] = j, j>i (j is the termination of i)
    // if i is a chute, d[i] = undefined
    // if i is a normal square, d[i] = i
    if(n <= 6) return {0, d[n]}; //trivially solved by rolling once
    struct square {
        int count; // count of times of rolls
        vector<int> seq; // quickest sequence to reach square i
    }
    // initialization
    vector<square> dp;
    dp.push_back( {0, {}} );
    for(int i = 1; i <= n; ++i) {
        if(i>=1 && i<=6 && d[i] != undefined) dp.push_back( {1, {i} } ) // roll once, sequence = {i}
        else dp.push_back( {infinity, {} } );
    }
    for(int i = 1; i <= 6; ++i) {
        if(d[i]>i) {
            dp[d[i]].count = 1;
            dp[d[i]].seq = dp[i].seq; // climb to d[i]
        }
    }
    // start finding sequence
    for(int i = 7; i <= n; ++i) {
        if(d[i] == undefined) continue;
        int min_predecessor_count = dp[i-6].count;
        int min_predecessor_index = i-6;
        for(int s = i-5; s <= i-1; ++s){
            if(dp[s].count < min_predecessor_count){ //find min count & index
                min_predecessor_count = dp[s].count
                min_predecessor_index = s;
            }
        }
        dp[i].count = min(min_predecessor+1, dp[i]);
        //notice that whenever we reach i, we either roll a dice from its 6 predecessor
        //or we have reached i through a ladder 1 <= k < i. if we reached i before, seq[i] = k, dp[i] != infinity. Denote i's predecessor's index as k if i has one. We can also simply find k by looking at the last element of dp[i].seq.back()
        if(dp[i].count < dp[min_predecessor_index].count + 1){ //it is cheaper to reach i through k
            //we do nothing since it has had a quickest sequence
        } else {
            dp[i].seq = dp[min_predecessor_index].seq.add_square(i); //add i since need to roll to i
        }
        
        if(d[i] > i) { // i is ladder
            dp[d[i]].count = min(dp[min_predecessor_index].count + 1, dp[d[i]].count);
            if(dp[min_predecessor_index].count+1 < dp[d[i]].count) { // we roll to i once from min_predecessor_index
                dp[d[i]].seq = dp[min_predecessor_index].seq; //don't need to add d[i] since we climb there
            }
        }
    }
    
    return dp[n].seq; //if dp[n].count == infinity or dp[n].seq.size() == 0, can't reach n
}
		\end{lstlisting} 
\end{proof}



\begin{proof}[Explanation]{}
		\renewcommand{\qedsymbol}{} % hide the QED square
        I'll explain some variable used in pseudo-code above here

        \textbf{int[] d:} this is an input array that the problem provides, d[i] stores the information for each square, as explained from line 3 to 7

        \textbf{struct square:} this is a collection of information for each square i, i$\in$[0,n]. \textbf{square.count} stores the how many times to get to i, \textbf{square.seq} stores the sequence of roll to get i. Notice that if we get i by climbing a ladder, we won't need to record i into the sequence since we only need the sequence of rolling dice.
        
        \textbf{vector<Square> dp:} dp[] needs n+1 elements since the map ranges from 0 to n (Don't consider the '/' char here since it's a pseudo-code). i $\in$ [0 , n], dp[i] stores two information through \texttt{struct square}. dp[i].count is the fewest times of rolling a dice to get i, dp[i].seq is the sequence of rolling a dice to get i. Notice that, for every i$\in$[0,n], if i is a chute, we simply skip them in the loop since we will never roll a dice to get to a chute and if we get to this chute through a ladder before, its information has been updated when we found the ladder, we will prove this later.
        
        \textit{Initialization:} \textbf{dp[0] = \{0,\{\}\}} because we start at 0. \textbf{For i=1,2,3,4,5,and 6,} we initialize dp[i].count = 1, dp[i].seq = \{i\} if they are not chutes since we can roll from 1-6 from starting point 0 and get to i and it takes indeed fewest step for i. \textbf{For the i$\in$[7:n],} we initialize dp[i].count = $\infty$ and dp[i].seq = \{\} since we haven't reach them before we start finding them. Then we look back to i=1,2,3,4,5,6, if i is a ladder, we also update dp[d[i]].count = 1 where d[i] is the destination of ladder i because they only take one roll to arrive i and then to d[i], dp[d[i]].seq = dp[i].seq because we only need to roll once to get to i and then d[i].

       
\end{proof}

\subsection*{Proof}
\begin{proof}[Correctness]{}
    For notation, count = $\infty$ and seq = \{\} are dummy values to denote a square has never been reached. For each square, it stores information about the count and seq that corresponds to each other. Saying the information for a square i is optimal simply means dp[i].seq is the sequence that takes fewest times of roll and dp[i].count stores the times of roll. First, let's prove some properties in the algorithm that we'll use in proof.
\subsubsection*{Property 1}
    For i$\in$[7,n], if we have reached some ladder k before, 1$\leq$k$<$i S.T. d[k] = i, dp[d[k]] = dp[i] will store some "count" of rolls and "seq" that take temporarily fewest rolls before we do comparison with i's 6 predecessor (count != $\infty$, seq != \{\}).
    \begin{proof}{Property 1}
         Observing the algorithm on line 35-37, 51-53, whenever we found a ladder k, we always take a look at its destination square, denoted as i, d[k] = i. There are two ways to reach i: (1) We have already reached i through some ladder k' before, 1$\leq$k'$<$i (2) We roll a dice from [k-6:k-1] to arrive i and climb to d[i]. This takes us min(dp[k-6:k-1].count) rolls plus another roll to i. Then, we do a comparison between (1) and (2) and update dp[i].count and dp[i].seq with the sequence that takes fewer times of roll. If it's the first time we reach i, dp[i].count = $\infty$ > min(dp[k-6:k-1].count)+1, dp[i] has stored the information that is temporarily optimal before we loop to i and check. If it's not the first time, we either replace square information with sequence taking fewer steps or and don't change the original information since it's better. Notice that in this case, dp[i].seq won't include i itself because we didn't roll to reach i.
         
         Since d[k] = i > k, whenever we loop to check i, we have already check k before (for loop property). Since we update the dp[d[k]] if k is a ladder, we have stored the optimal information for dp[d[k]] when we loop to d[k] before checking with d[k]'s 6 predecessor.
    \end{proof}

\subsubsection*{Property 2}
    For i$\in$[7,n], when we loop to check square i (starting from line 31), dp[i] will always store the information for the sequence with less times of roll when finishing checking.
    \begin{proof}
        Notice that we only have two ways to reach a square: roll a dice from its 6 predecessor or through some ladder 0 $\leq$ k $<$ i.
        (1) If i is a chute, the algorithm simply skip it since we will never roll a dice to reach a chute. Therefore, either we have reached i before through ladder k and the information for i has been updated when we reach k (Property 1), or we have never reached i and will never reach i and dp[i].count = $\infty$ dp.seq = \{\}.
        (2) If i is a ladder or a normal square, the algorithm compares its current reaching sequence rolling times with min(dp[i-6:i-1].count) + 1 and stores the better information on line 35 - 41. If we reach i through rolling once from its one of its 6 predecessors, the sequence will add i.
    \end{proof}

\subsubsection*{Property 3}
    For i$\in$[1,n], dp[i].count and dp[i].seq always correspond to each other.
    \begin{proof}
        Notice that the algorithm updates dp[i].seq and dp[i].count at the same time only when dp[i].count can become smaller. Therefore, even though there might be different sequences to reach a same square i, dp[i].seq and dp[i].count are always paired.
    \end{proof}

\subsubsection*{Property 4}
    The algorithm terminates.
    \begin{proof}
        Since the algorithm only use for loop on local variable i and s, all of which only have ++i or ++s operation on its value, the algorithm always terminates.
    \end{proof}
\subsubsection*{Lemma}
    For i$\in$[7,n], when we finish checking i-1 square, dp[i].seq always store the optimal sequence information that takes fewest times of rolls
    \begin{proof}
        According to Property 1, whenever we reach a ladder 1$\leq$k$<$i S.T. d[k] = i, dp[d[k]] = dp[i] will store a temporarily optimal information about the sequence for reaching i. We prove this by induction on k.
        
        \textbf{Base Case:} k=1, if k is a ladder and reach i, dp[i] has been updated in the initialization. if not, we still not yet find a way to i and dp[i].count stays $\infty$ and dp[i].seq = \{\}.
        
        \textbf{Inductive Hypothesis:} the claim holds true for  1$\leq$k$<$i-2.
        
        \textbf{Inductive Step:} When we start checking i-1, if d[i-1]=i, the algorithm compare this sequence to the one d[i] has already have. By Property 1, if i-1 is a ladder that leads to i, we always keep the temporarily best result. We compare the temporarily best sequence to reach i from 1 to i-2 (by strong IH) with the one from i-1. Since the algorithm always pick the better one, dp[i].seq stores the best possible sequence to arrive itself through a ladder after we checking(comparing) i-1.
        
        When we finish checking i-1 square, we have finished checking every possible ladder for i. In each iteration, we will pick a better sequence if there is one if we can get i through ladder k with fewer rolls, we pick the one with the fewest times of rolls when we finish checking i-1 square.
        
        This completes the inductive step and thus the proof.
    \end{proof}
\subsubsection*{Correctness}
Now, let's start proving the correctness with the properties and lemma.
For a optimal solution to reach a square i, either (1) we reach their by rolling a dice once from its 6 predecessor or (2) we reach their by climbing a ladder before.

We know that the optimum way of getting q involves one of the following two:

1. roll a dice once from q-6 or q-5 or ... or q-1 and reach q, incur the sequences to  q-6, q-5, ..., q-1 are *optimal*

2. we reach q through some ladder 1$\leq$k$<$i, incur the sequences to k is *optimal*

The optimum does the best of the two.

\textbf{Subproblems:} find the sequence of roll to get square q with fewest times of rolls for q = 0, ..., n.

Define \texttt{\\OPT(q) := times of roll of the sequence to reach q with fewest times of roll \\OPT$_{temp}$(q) := times of rolls of the sequence to reach q through a ladder after checking q-1}

\textbf{Recurrence Relation:} \texttt{\\OPT(q) = min( min( OPT(q-1), OPT(q-2), OPT(q-3), OPT(q-4), OPT(q-5), OPT(q-6) ) + 1, OPT$_{temp}$(q) )}

\textbf{Base Case:} OPT(0)=0, OPT(1)= OPT(2) = OPT(3) = OPT(4) = OPT(5) = OPT(6) = 1

By Property 3, dp[q].count and dp[q].seq are always paired. Therefore, finding the min times of roll means finding the best sequence. To prove: dp[n].count = OPT(n), dp[n].seq is the optimal

\textbf{Base case:} i = 0, dp[0].count = 0, i = 1,2,...,6 dp[i].count = 1 = OPT(i).

\textbf{Induction Hypothesis:} algorithm finds the best sequence (fewest times of rolls) to reach i for 0$\leq$i$\leq$n-1.

\textbf{Inductive Step:} The algorithm assigns dp[n].count with \texttt{min( min(dp[n-6:n-1].count) + 1, dp[n])} and dp[n].seq with corresponding sequence by property 3. By Lemma, when we finish checking n-1, dp[n].count = OPT${_temp}$(n) is indeed the best sequence to reach n through a ladder. By strong IH, \texttt{min(dp[n-6:n-1].count) = min( OPT(n-6), OPT(n-5), ..., OPT(n-1) )}, therefore, \texttt{dp[n].count = min( min(OPT(n-6), OPT(n-5), ..., OPT(n-1))+1, OPT$_{temp}$(n) )} = OPT(n) [by recurrence relation]. By Property 3, dp[n].count and dp[n].seq always correspond. Therefore, dp[n].seq is the optimal since dp[n].count = OPT(n)

This completes the inductive step and thus the proof.

\end{proof}

\subsection*{Running Time}
\begin{proof}[Running Time]{Analyze the algorithm running time}
    	\renewcommand{\qedsymbol}{}
    	From line 12 to 19, setting variables and assignment takes $\mathcal{O}(1)$. From line 20 to 23, this takes $\mathcal{O}(n)$ for looping n element and $\mathcal{O}(1)$ assignment. From line 24 to 29, it takes $\mathcal{O}(1)$ for looping six elements and $\mathcal{O}(1)$ assignments. From line 31 to 56, it takes $\mathcal{O}(n)$ for looping n-6 elements and $\mathcal{O}(1)$ assignment inside (line 35 to 40 simply find the smallest predecessor and corresponding index, it takes $\mathcal{O}(1)$ for six elements).
    	
    	Thus the running time $T(n)$ will be \[T(n)=2\mathcal{O}(n)+2\mathcal{O}(1)=\mathcal{O}(n)\]
\end{proof}

\section*{Problem 2}





% END MAIN Doc
\end{document}
