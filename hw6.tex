\documentclass[openany]{article}

%Typesetting and language
\usepackage[american]{babel}
\usepackage[T1]{fontenc}
\usepackage{charter}
\usepackage{enumitem}
\usepackage{hyperref}

%Symbols
\usepackage{amssymb, amsmath, amsthm, bm}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{marvosym}
\usepackage{MnSymbol}

%Colors & graphics
\usepackage[dvipsnames]{xcolor}
\usepackage{pgfplots}
\usepackage[numbered,framed]{matlab-prettifier}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\usepackage[object=vectorian]{pgfornament}
\usepackage{wrapfig}
\usepackage{varwidth}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{caption}
\usepackage{float}
\usepackage{geometry}
\usepackage{ulem}
\usepackage[most]{tcolorbox}
\usepackage{array}

\setlength{\parindent}{0pt}

\makeatletter
\g@addto@macro\bfseries{\boldmath}
\makeatother


\renewcommand{\Re}{\mathfrak{Re}}
\renewcommand{\Im}{\mathfrak{Im}}

\geometry{left=2cm,right=2cm,bottom=2cm,top=2cm}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\sectionmark}[1]{\markright{\arabic{section} - #1}}
\cfoot{\thepage}
\lhead{CS270}
\chead{HW6}
\rhead{Adam Yang}
\renewcommand{\headrulewidth}{1pt}


\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Fix}{Fix}
\DeclareMathOperator{\Stab}{Stab}
\DeclareMathOperator{\cov}{cov}
\DeclareMathOperator*{\esssup}{ess\,sup}
\DeclareMathOperator{\corr}{corr}
\DeclareMathOperator{\lik}{lik}
\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax}

\newcommand{\niceline}[2]{%
		\nointerlineskip \vspace{.5\baselineskip}\hspace{\fill}
		{\color{#1}
				\resizebox{0.5\linewidth}{2ex}
				{{%
								{\begin{tikzpicture}
										\node  (C) at (0,0) {};
										\node (D) at (9,0) {};
										\path (C) to [ornament=#2] (D);
										\end{tikzpicture}}}}}%
		\hspace{\fill}
		\par\nointerlineskip \vspace{.5\baselineskip}
}

\definecolor{darkViolet}{HTML}{9400D3}
\newcommand{\sweetline}{%
		\noindent
		\begin{center}
				{\color{darkViolet}
						\resizebox{0.5\linewidth}{1ex}
						{{%
										{\begin{tikzpicture}
												\node  (C) at (0,0) {};
												\node (D) at (9,0) {};
												\path (C) to [ornament=85] (D);
												\end{tikzpicture}}}}}%
		\end{center}
}

\definecolor{remarkPurple}{HTML}{8346FF}
\definecolor{defBlue}{HTML}{0673FF}
\definecolor{exPurple}{HTML}{FF8710}

%THEOREM
\newtcbtheorem[auto counter,number within=section]{theorem}{Theorem}%
{enhanced,colback=white, breakable,frame empty,interior empty,colframe=cyan!50!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=cyan!15!white,
				borderline={0.5mm}{0mm}{cyan!15!white},
				borderline={0.5mm}{0mm}{cyan!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{thm}

%PROPOSITION
\newtcbtheorem[use counter from=theorem]{proposition}{Proposition}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prop}

%DEFINITION
\newtcbtheorem[use counter from=theorem]{definition}{Definition}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{def}

%COROLLARY
\newtcbtheorem[use counter from=theorem]{corollary}{Corollary}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{cor}

%REMARK
\newtcbtheorem[no counter]{remark}{Remark}%
{detach title, colback=white,enhanced ,breakable,frame empty, interior empty, fonttitle=\bfseries, coltitle=Violet, before upper={\tcbtitle.\quad},
				borderline west={0.5mm}{0mm}{remarkPurple!40!white},
				borderline west={0.5mm}{0mm}{remarkPurple!60!white,dashed}}{remark}

%LEMMA
\makeatletter
\newtcbtheorem[number within = tcb@cnt@theorem]{lemma}{Lemma}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=orange!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=orange!20!white,
				borderline={0.5mm}{0mm}{orange!20!white},
				borderline={0.5mm}{0mm}{orange!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{lemma}
\makeatother


%PROOF
%%{enhanced,breakable,frame empty,interior empty,colframe=remarkPurple!75!white, top=8mm,
%	coltitle=black,fonttitle=\bfseries,colbacktitle=remarkPurple!20!white,
%	borderline={0.5mm}{0mm}{remarkPurple!20!white},
%	borderline={0.5mm}{0mm}{remarkPurple!50!white,dashed},
%	attach boxed title to top left={yshift=-4mm},
%	boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prf}


\tcolorboxenvironment{proof}{% amsthm' 
				blanker,breakable,left=5mm,
				before skip=10pt,after skip=10pt,
				borderline west={0.5mm}{0pt}{cyan!40},
				borderline west={0.5mm}{0pt}{remarkPurple!10, dashed}}

%PROBLEM
\newtcbtheorem[auto counter]{problem}{Problem}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=cyan!50!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=cyan!20!white,
				borderline={0.5mm}{0mm}{cyan!20!white},
				borderline={0.5mm}{0mm}{cyan!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prob}

%EXAMPLE
%\newtcbtheorem[use counter from=problem]{example}{Example}%
%{enhanced,breakable,colback=white,frame empty,interior empty,colframe=remarkPurple!50!white, top=8mm,
%		coltitle=black,fonttitle=\bfseries,colbacktitle=remarkPurple!30!white,
%		borderline={0.5mm}{0mm}{remarkPurple!30!white},
%		borderline={0.5mm}{0mm}{remarkPurple!30!white,dashed},
%		attach boxed title to top left={yshift=-4mm},
%		boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{ex}


\newtcbtheorem[use counter from=theorem]{example}{Example}%
{detach title, colback=white,enhanced ,breakable,frame empty, interior empty, fonttitle=\bfseries, coltitle=black, before upper={\tcbtitle.\quad},
		borderline west={0.5mm}{0mm}{remarkPurple!30!white},
		borderline ={0.5mm}{0mm}{remarkPurple!30!white}}{example}

%SOLUTION
\newtcbtheorem[no counter]{solution}{Solution}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=green!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=green!20!white,
				borderline={0.5mm}{0mm}{green!20!white},
				borderline={0.5mm}{0mm}{green!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{sol}
\definecolor{realPurple}{HTML}{AA05F9}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
				style=Matlab-editor,
				language=C,
				aboveskip=3mm,
				belowskip=3mm,
				xleftmargin=3mm,
				showstringspaces=false,
				columns=flexible,
				frame=none,
				basicstyle={\small\ttfamily},
				numberstyle=\tiny\color{gray},
				keywordstyle=\color{blue},
				commentstyle=\color{dkgreen},
				stringstyle=\color{mauve},
				breaklines=true,
				breakatwhitespace=true,
				mlshowsectionrules = true,
				tabsize=3,
				backgroundcolor=\color{cyan!5}
}

\newcommand\mmybox[2][fill=cyan!20]{%
    \tikz[baseline]\node[%
        inner ysep=0pt, 
        inner xsep=2pt, 
        anchor=text, 
        rectangle, 
        rounded corners=1mm,
        #1] {\strut#2};%
}


\def\changemargin#1#2{\list{}{\rightmargin#2\leftmargin#1}\item[]}
\let\endchangemargin=\endlist

\linespread{1.4}



% MAIN DOC
\begin{document}

\title{HW 6}
\author{Adam Yang}
% \date{\today}
\maketitle




\section*{Problem1}

In the following answer, denote $n$ as total days to detect, $k$ as total target days of drought, $p_i\in [0,1]$ as the probability of rain in $i$-th day, $i\in [0,n]$ $\Rightarrow (1-p_i)$ is the probability of drought on $i$-th day. All $p_i$ are independent. We will focus on number of drought days in the following discussion.

\subsection*{Algorithm}
\begin{proof}[Algorithm]{}
		\renewcommand{\qedsymbol}{}
		An Algorithm to compute the probability that more than k days will be drought days in 2023
		\begin{lstlisting}[basicstyle=\fontsize{8}{9}\selectfont\ttfamily]
/**
* p[] is the input probability list, p[i] stores probability p_i of raining in i-th day, index from 0 to n, p[0] = 0
* n is the observing days
* k is the targeting days
* in the following code, dp[i][j] stores the probability that i days have j days drought
**/
float findProb(float[] p, int n, int k){
	float[][] dp = new dp[n+1][n+1]; // +1 for extra 0 bases
    set (n+1)*(k+1) all entry in dp[][] to 0;
    dp[0][0] = 0;
    dp[1][0] = p[1]; // 1 day AND 0 day drought = p_1
    dp[1][1] = 1-p[1]; // 1 day AND 1 day drought = 1-p_1
    // initialization
    for(int i = 2; i <= n; ++i){
      dp[i][0] = dp[i-1][0] * p[i];
      dp[i][i] = dp[i-1][i-1] * (1-p[i]);
    }
    // start finding
    for(int i = 1; i <= n; ++i){
      for(int j = 1; j < i; ++j){ // never reach dp[i][i], which has been initialized
          dp[i][j] = dp[i-1][j]*p[i] + dp[i-1][j-1]*(1-p[i]);
      }
    }
    float res;
    for(int i = k+1; i <= n; i++) res += dp[n][i];
    return res;
}

        
		\end{lstlisting} 
\end{proof}

\subsection*{Proof}
\begin{proof}[Correctness]{}
The goal is to find the probability of more than $k$ days are drought in n days.

\textbf{Analysis:} Let $X$ be the number of drought days, $P_n(X=i)$ be the probability of there are $i$ days drought in $n$ day, $R$ be the event of raining, $D$ be the event of drought. Notice that $R_i=D_i^c$.

Since the raining and drought in each day is independent \[P_n(k<X\leq n) = P_n(X=k+1, X=k+2, ..., X= n)\] \[= P_n(X=k+1) + ... + P_n(X=n) = \sum_{j=k+1}^{n}P_n(X=j), k \leq n\]

Notice that it is impossible to have k days drought in n days if $k>n$, therefore $P_n(X\leq n < k) = 0$ Since this is vacuously true to say the probability is zero, the following discussion will only focus on $k\leq n$ scenario.

\textbf{Sub-problem:} Define the sub-problem $j$ to be finding the probability that there are exactly $j$ drought days in n days, $i\in[0,n]$.
    
\textbf{Recurrence Relation:} Define the probability of $j$ days drought in $i$ days,  $0\leq j<i\leq n$ as $P_i(X=j)$.

1. If $i$-th day is raining, then there have been $j$ days drought already in previous $i-1$ days.

2. If $i$-th day is drought, then there have been $j-1$ days drought already in previous $i-1$ days.

Thus, the probability that there are exactly $j$ drought days in $i$-th day is \[P_i(X=j) = P_{i-1}(X=j|R_i) + P_{i-1}(X=j-1|D_i)\]
\[=p_i P_{i-1}(X=j) + (1-p_i)P_{i-1}(X=j-1)\]

Therefore, the probability that exactly $i$ days are drought in $n$ days has the recurrence relation:
\[P_n(X=i) = p_n P_{n-1}{X=i} + (1-p_n)P_{i-1}{X=i-1}, i\leq n\]
    
    
\textbf{Base Cases:}

1. There is zero drought day in zero day. $P_0(X=0)=0$

2. There is zero drought day in one day. $P_1(X=0)=p_1$

3. There is one drought day in one day. $P_1(X=1)=1-p_1$

4. There is zero drought day in $i$ day, $i\in[1,n]$, $P_i(X=0)=p_i P_{i-1}(X=0)$

5. There is $i$ day drought in $i$ day, $i\in[2,n]$,
$P_i(X=i)=(1-p_i)P_{i-1}(X=i-1)$
    
\textbf{Edge Case}:

1. There are $j$ drought days in $i$ days, $i<j$. $P_i(X=j) = 0$

\textbf{Correctness Proof:}

Correctness statement: $\sum_{j=k+1}^{n}$dp[$n$][$j$] = $P_n(k<X\leq n)$
  
We will prove along the way: dp[$i$][$j$] = $P_i(X=j)$ for all $ 0 \leq j < i \leq n$

\textbf{Proof by induction on $i+j$:}

\textbf{Inductive Hypothesis:} For all $0 \leq i'+j'<i+j,0 \leq j < i \leq n$, dp[$i'$][$j'$] = $P_{i'}(X=j')$

\textbf{Base Cases:}

1. dp[0][0] = 0 = $P_0(X=0)$

2. dp[1][0] = $p_1$ = $P_1(X=0)$

3. dp[1][1] = $1-p_1$ = $P_1(X=1)$

\textbf{Inductive Cases:}

1. dp[i][j] = $p_i \times$ dp[i-1][j] + $(1-p_i) \times$ dp[i-1][j-1] \textit{*by Assignment*} \\= $p_i P_{i-1}(X=j) + (1-p_i)P_{i-1}(X=j-1)$ \textit{*by Inductive Hypothesis, $i-1+i < i+j, i+j-2 < i+j$*}
\\= $P_i(X=j)$ \textit{*by Recurrence Relation*}

2. dp[i][0] = $p_i \times$ dp[i-1][0] \textit{*by Assignment*}\\=  $p_i P_{i-1}(X=0)$ \textit{*by Inductive Hypothesis, $i-1 < n+k$*}\\= $P_i(X=0)$  \textit{*by Recurrence Relation*} for $2\leq i \leq n$ 

3. dp[i][i] = $(1-p_i) \times$ dp[i-1][i-1] \textit{*by Assignment*} \\= $p_i P_{i-1}(X=i-1)$ \textit{*by Inductive Hypothesis, $2i-2 < n+k$*} \\=   $P_i(X=i)$ \textit{*by Recurrence Relation*} for $2\leq i \leq n$

4. Edge Case ($i>j$), dp[i][j] = 0 \textit{*By Assignment*} = $P_j(X=i)$ \textit{*By IH and Recurrence*}
\end{proof}
\begin{proof}[Termination]{}
    All for loop algorithm, vacuously true. It terminates.
\end{proof}

\subsection*{Running Time}



\section*{Problem2}

\subsection*{Algorithm}
In the following answer, $G = (V,E)$ is the directed graph we will discuss and $x=x_1x_2\cdots x_T$ is the string to compute. Denote $|V|$ as $n$, $|E|$ as $m$, size of $x$ as $T$, starting node as $s$, $e(u,v)$ as an edge $u \rightarrow v$, $u,v\in V$. We store a 2D array \texttt{a[][]}. For convenience, all nodes have a unique corresponding index to store in a[v][k], $v\in V, k\in [0, T]$.

For each node $v\in V$, v stores array q[] for the likelihood of outputting a letter from 'a' to 'z'; and p[] for the likelihood of picking an out-going edge to another node: v.q[$x_i$] is the probability of node $v$ output $x_i, i\in [1...T], x_i\in \{'a','b', \cdots, 'z'\}$; v.p[u] is the probability of node v goes to $u \neq v, u \in V$ through an out-going edge $e(v,u)$, if no such $e$ then probability is 0. 

\begin{proof}[Algorithm]{}
		\renewcommand{\qedsymbol}{}
		An Algorithm to find the maximum likelihood of any vertex sequence for the given string
		\begin{lstlisting}[basicstyle=\fontsize{8}{9}\selectfont\ttfamily]
Define Graph G = (V,E) where V is the node set and E is the edge set;

// it is C++ like pseudo-code, max_element and push_back() are functions for vector<T> in STL
/**
* Graph G is the input G=(V,E)
* x is the input string to compute
* x indexed from 1 to T
**/

float findProb2(Graph G, String x){
    n := size of V;
    m := size of E;
    T := size of x;
    initialize a 2D array a[n][T], set each place to 0;
    a[s][1] = s.q[x[1]];
    for(int k = 2; k <= T; k++){
        for(all node v in V){
            vector<float> temp; // help find max item
            for(all node u S.T e(u,v) exists){
                temp.push_back(a[u][k-1] * u.p[v] * s.q[x[k]]);
            }
            a[v][k] = max_element(temp.begin(), temp.end())
        }
    }
    float res = 0;
    for(all node v in V){
        if(a[v][k] > res) res = a[v][k];
    }
    return res;
}

        
		\end{lstlisting} 
\end{proof}



\begin{proof}[Explanation]{}
		\renewcommand{\qedsymbol}{} % hide the QED square
       
\end{proof}

\subsection*{Proof}
\begin{proof}[Correctness]{}
    
    
\textbf{Goal:} 

\textbf{Analysis:} 
    
\textbf{Subproblem:}

    
\textbf{Recurrence Relation:}
    
    
\textbf{Base Case:}
    
    
\textbf{Correctness Proof:}

    
  

\end{proof}
\begin{proof}[Termination]{}

\end{proof}

\subsection*{Running Time}



\end{document}
