\documentclass{article}
\author{Shixiang (Adam) Yang}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}

\SetKwInput{KwInput}{Input}                % Set the Input
\SetKwInput{KwOutput}{Output}              % set the Output
\date{September 30, 2022}
\title{CSCI270 - Assignment4}
% \graphicspath{{./media/}}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz} 
\usepackage{amsfonts}
\usepackage{indentfirst}
\setlength\parindent{24pt}
\begin{document} \maketitle
\section{Problem 1}
This problem is mainly using Master Theorem to solve the recurrence relations.
\subsection{}
$a = 9, b = 3, k = 2, p = 0$

$n^{\log_b{a}} = n^{\log_3{9}} = n^2$

$f(n) = c_1n^2=\Theta(n^2) = \Theta(n^{\log_b{a}})$

$T(n) = \Theta(f(n)*\log{n}) = \Theta(n^{\log_3{9}}*log^{0+1}{n}) = \Theta(n^2\log{n})$

\subsection{}

$a=10, b=5, k = 1/5$

$n^{\log_b{a}}=n^{\log_5{10}}$

Let $x = \log_5{10}, y = 1.5$
$5^x = 10, 5^y = 5^{3/2} = \sqrt{125} > 10$

Therefore, $x < y, n^{\log_5{10}} < n^{1.5} = f(n)$

$f(n) = c_2n^{1.5} = \Omega(n^{\log_5{10}+\epsilon})$

Since $n^{\log_5{10}} < 1.5$, $\epsilon >0$. By Master Theorem:

$T(n) = \Theta(f(n)) = \Theta(n^{1.5})$

\subsection{}

$a=3,b=4,k=1/2$

$n^{\log_b{a}} = n^{\log_4{3}}$

Let $x=\log_4{3}, y = 1/2, 4^x = 3 > 4^y = 2$

Therefore, $x>y, n^{\log_4{3}} > \sqrt{n} = f(n)$

$f(n)=c_3\sqrt{n}=O(n^{\log_4{3}-\epsilon})$

Since $\log_4{3} > \frac{1}{2}$, $\epsilon > 0$. By master theorem:

$T(n)=\Theta(n^{\log_4{3}})$

\subsection{}

Since $T(n) = T(\frac{n}{3}) + T(\frac{2n}{3}) +c_4n$, the tree generated by this recurrence relation has shortest height $\log_3{n}$ and deepest height $\log_{\frac{3}{2}}{n}$. Observing the tree, every level is $c_4n$.

Consider the lower bound: The tree stops at the shortest height. 
\[\Omega(c_4n\log_3{n})=\Omega(n\log{n})\]

Consider the upper bound: the tree stops at the deepest height.
\[O(c_4n\log_{\frac{3}{2}}{n}) = O(n\log{n})\]

Therefore, we have $T(n) =\Theta(n\log{n})$

\subsection{}
In the first layer: $\Theta(c_5n)$

In the second layer: $\Theta(c_5*n/4+c_5*n/2) = \Theta(c_5*3n/4)$

In the third layer: $\Theta(n/16+n/8+n/8+n/4)=\Theta(9n/16)$

In the i-th layer:
$\Theta((\frac{3}{4})^{i-1}n)$

Assume there are $k$ layers, we have: $n/{2^k}=1, k = \log{n}$

$T(n)=\sum_{i=1}^{\log{n}}(\frac{3}{4})^{i-1}n=n*\frac{1-(3/4)^{\log{n}}}{1-3/4}$

Notice that \[c_5n \leq T(n) \leq \lim_{n \to -\infty}n\frac{1-(3/4)^{\log{n}}}{1-3/4}=4n\]

Therefore, the lower bound is $\Omega(n)$, the upper bound is $O(4n)=O(n)$.

$T(n) = \Theta(n)$

\section{Problem 2}
\subsection{Problem a}
We prove by contradiction. Assume that for $i\in [1,n-1]$, there is no such pair ($a_i, a_{i+1}$) that $a_i < a_{i+1}$ in $A$. That is, $\forall i\in[1,n+1]: a_i \geq a_{i+1}$ in $A$. Therefore, $a_1 \geq a_2 \geq a_3 ... \geq a_{n-1} \geq a_{n}, a_1 \geq a_n$. Because $a_1 < a_n$, contradiction! Therefore, there exists at least one desired pair in A. $\square$
\subsection{Problem b}
\begin{algorithm}[!ht]
\DontPrintSemicolon
\KwInput{$A[ ]$, lower bound $l$, upper bound $u$ (we only search $A[l:u]$)}
  \SetKwFunction{FSub}{Find} 
    \SetKwProg{Fn}{Def}{:}{} 
      \Fn{\FSub{$A[ ]$, $l$, $u$}}{ 
    \If{$l==u$}{
        return -1;  \tcp*{can't find a pair from a single element}
    } \Else{
          $m \leftarrow \lfloor\frac{u+l}{2}\rfloor$
          
          \If{$A[m] < A[m+1]$}{
            return $m$
          } \Else {
            \If{$A[l] \geq A[m]$}{
                return Find($A[], m+1, u$)
            } \Else{
                return Find($A[ ], l, m$)
            }
          }

    }
      }
    desiredPairIndex $\leftarrow$ Find($A[], 1,n$)
      \;

\caption{An algorithm finding a pair ($a_i < a_{i+1}$) and output index $i$}
\end{algorithm}

\textbf{Correctness:} The output is a pair ($a_i<a_{i+1}$) for $i\in [1,n-1]$ in A. Proven in problem a, an array A with $a_1 < a_n$ must has a pair ($a_i,a_{i+1}$) such that $a_i<a_{i+1}$ on $A[1:n]$. From line 6 to 12 in the following algorithm, we explicitly choose the subarray $Sub[] = A[l:m]$ or $Sub[]=A[m+1:u]$ with size $p$ that satisfies $Sub[1] < Sub[p]$ to work on.

\textbf{Lemma:} if the input array A[l:u] has $A[l] < A[u], m=\lfloor \frac{l+u}{2}\rfloor$, the algorithm always chooses a subarray  $Sub[] = A[l:m]$ or $Sub[]=A[m+1:u]$ with size $p$ that satisfies $Sub[1] < Sub[p]$ and contains the desired pair for the algorithm to work on. In other words, the algorithm always choose the subarray that involves the desired pair.

\textbf{Proof of Lemma:} To prove the lemma, we always assume that the input array $A[]$ has at least two elements because the algorithm doesn't concern finding the subarray for the array that has only one element. When the array $A[]$ only has two elements, it means we have found the element since the $A[1]<A[2]$. WLOG, let's look at the array $A[]$ indexed from $1$ to $n$, $A[1] < A[n], n>1$. In this case, $l = 1, u = n, m=\lfloor \frac{l+u}{2}\rfloor$. There are three cases here:
\begin{enumerate}
    \item $A[m] < A[m+1]$: we don't need to concern about the subarray here since the algorithm will terminate once finding the desired pair.
    \item $A[m] \geq A[m+1]$ \textbf{and} $A[l] \geq A[m]$: because $A[m+1] \leq A[m] \leq A[l] < A[u]$, $A[m+1] < A[u]$. Therefore, the subarray $Sub[] = A[m+1:u]$ with size $p$ has $Sub[1] = A[m+1] < A[u] = Sub[p]$
    \item $A[m] \geq A[m+1]$ \textbf{and} $A[l] < A[m]$: the subarray $Sub[]=A[l:m]$ with size $p$ has $Sub[1] = A[l] < A[m] = Sub[p]$
\end{enumerate}
Therefore, when the size of $A[]$ is at least 2, either the algorithm terminates for finding desired pair or keeps working on a subarray $Sub[]$ that has the first element strictly less than the last element and contains the desired pair. Lemma Proved! The algorithm always picks the subarray that involves the desired pair.

\textbf{Theorem [Algorithm Correctness]:} If you call Find($A[ ], l, u$), it terminates, and afterwards, it returns a pair ($a_i<a_{i+1}$) for $i\in [1,n-1]$ in $A[l:u]$.
\\By induction on $n = u-l+1$ (size of the array that we are working on)
\\\textbf{Base Case:} n=1 (l==u), algorithm does nothing since there's only one element we are working on. We return null since there is no a pair.
\\\textbf{Inductive Hypothesis:} Assume that the algorithm works for all array size $1, 2, ..., n-1$
\\\textbf{Inductive Step:} We get to assume that algorithm works
for all array sizes 1, ..., n-1 (Strong induction hypothesis.) 
\\Sizes for recursive calls:
\begin{enumerate}
    \item $m-l+1 = \lfloor \frac{l+u}{2}\rfloor - l + 1 < u-l+1=n$
    \item $u-(m+1)+1 = u-\lfloor \frac{l+u}{2}\rfloor < u-l+1=n$
\end{enumerate}

The lemma tells us that when the size of input array $A$ is at least two, the algorithm always find the subarray that has the first element strictly less than the last element to work on. Because both subarrays are smaller and we only choose the subarray that contains the desired pair to work on, we can use the inductive hypothesis on choosen recursive call that will terminate, and the result is the desired pair. $\square$

\textbf{Running time analysis:}\\
Observing the algorithm, on each level recursion of size $n$ we has another recursive call of size $n/2$ and primitive operation (comparison and assignment) that takes $\Theta(1)$. Assume the running time of algorithm with input array size of n as $T(n)$. The recurrence relation is \[T(n)=T(n/2)+\Theta(1)\]
By master theorem, $a = 1, b = 2, \log_b{a} = \log_2{1} = 0 < 1 = f(n)$. The running time is: \[T(n) = n^{\log_b{a}}*\log{n} = n^0*\log{n} = \log{n}\]

\section{Problem 3}

\textbf{Observation:} Since the input arrays size are always even and sorted, if we merge them and output a new array $s[]$ (stands for students array) we will also have a sorted array with even. By definition of median student, there exists at least two such students with index $n$ and $n+1$ if in $s[]$ (at least n students have scores no less and n students has scores no higher than median students.) Smaller median student has $n-1$ students on its left side and $n$ students on its right side. Larger median student has $n$ on left and $n-1$ on right. (Whenever \textbf{the left or right side} of a student is mentioned, it is \textbf{in the scope of merged array} s$[]$.)

By the definition of input arrays, $a[1]\leq a[2] ... \leq a[n]$,  $b[1]\leq b[2] ... \leq b[n]$. Therefore, it is possible that there are multiple students have the same score of desired median student $M$. Nevertheless, we only focus on finding either two of the desired median student.

Since $|s|$ is even, if we neglect same number of students from the left and right side of two median students, the leftover array is still size of even number and two median students stays the same.

\begin{algorithm}[!ht]
\DontPrintSemicolon
\KwInput{$a[ ]$,$b[]$, $l_a$, $u_a$, $l_b$, $u_b$ (indexed from 1 to n)}
  \SetKwFunction{FSub}{FindStudent} 
    \SetKwProg{Fn}{Def}{:}{} 
      \Fn{\FSub{$a[ ]$,$b[]$, $l_a$, $u_a$, $l_b$, $u_b$}}{ 
      \tcc{we only work on $a[l_a:u_a]$ and $b[l_b:u_b]$}
        $m_a \leftarrow \lfloor\frac{u_a+l_a}{2}\rfloor$
        
        $m_b \leftarrow \lfloor\frac{u_b+l_b}{2}\rfloor$
        
        \If{$a[m_a] < b[m_b]$}{
            \If{$a[m_a+1]<b[m_b+1]$}{
                return FindStudent($a[],b[], m_a+1, u_a, l_b, m_b$)
            } \Else {
                return $b[m_b+1]$
            }
        } \ElseIf{$a[m_a > b[m_b]$} {
            \If{$a[m_a+1]>b[m_b+1]$} {
                return FindStudent($a[],b[],l_a, m_a,m_b+1, u_b$)
            } \Else {
                return $a[m_a+1]$
            }
        } \Else { \tcc{$a[m_a]==b[m_a]$}
            return $a[m_a]$
        }
    }
    
    desiredMiddleStudent $\leftarrow$ FindStudent($a[],b[],1,n,1,n$)
      \;
\caption{An algorithm finding "most middle" student}
\end{algorithm}


\textbf{Correctness:} The output is a student $i$ (out
of the $2n$ total) such that at least $n$ students had scores no higher than $i$, and at least $n$ students had scores no lower than $i$. From line 17 to 26, the algorithm neglects equal number of students from each side and squeeze the searching range until we find $M$.

\textbf{Lemma:} The algorithm either (1) neglect same size of students from left and right side of median student M and keep finding (this happens only when the searching range on both arrays $n\geq 2$. When the searching range is 1, trivially we have $a[m_a] == b[m_b]$ thus finding the student) or (2) return the desired median student when we find them. We define $l_a, u_a$ as the lower bound and upper bound of array $a[]$'s range that algorithm is working on, $l_b, u_b$ as lower bound and upper bound of array $b[]$'s range that algorithm is working on.

\textbf{Proof of Lemma:} 
Given two sorted array $a[l_a: u_a], b[l_b:u_b]$ both of size $n$ ($u_a-l_a = u_b-l_b=n$). We have three cases to deal with \begin{enumerate}
    \item $a[m_a] < b[m_b]$ 
     
            \textbf{1.1} \textbf{$a[m_a+1]<b[m_b+1]$}\\
            The median student $M$ must lie on $a[m_a+1:u_a]$ or $b[l_b:m_b]$.
            \\\textbf{1) It cannot lie on }$a[l_a:m_a]$\\
             This can be proved by contradiction. Assume $M$ is in $a[l_a:m_a]$. Thus, there are at most $\frac{n}{2}-1$ students on the left side of $M$ ($a[l_a:m_a-1]$). Meanwhile, because $a[m_a]<b[m_b]$, there are at most $\frac{n}{2}-1$ students on the left side  $b[l_b:m_b-1]$. (If $m_b-1 < l_b$, we have nothing on this range, which trivially makes $M$ also contradicts the definition.) Therefore, there are at most $n-2$ students on the left side of $M$ if it lies on $a[l_a:m_a]$. By definition, the median student we find has at least n-1 students on its left side in the merged array $s[]$. Contradiction! Therefore, $M \geq a[m_a]+1$, the desired median mustn't exist in $a[l_a:m_a]$. 
            \\\textbf{2) It cannot lie on} $b[m_b+1: u_b]$.\\
            This can be also proved by contradiction. Assume the median student $M$ is in $b[m_b+1: u_b]$. Thus, there are at most $\frac{n}{2}-1$ students on $M$ right side ($b[m_b+2: u_b]$). Meanwhile, because $a[m_a+1] < b[m_b+1]$, there are at most $\frac{n}{2}-1$ students on its right side ($a[m_a+2:u_a]$). (When $m_a+2 < u_a$, we have nothing on this range, which trivially makes $M$ contradicts the definition.) Therefore, there are at most $n-2$ students on $M$ right side, which contradicts the definition. Therefore, the desired median cannot exist in $b[m_b+1:u_b]$.
        
            Since $a[l_a:m_a]$ cannot contain the desired $M$, we neglect these $\frac{n}{2}$ students on the left side of $M$. Similarly, $b[m_b+1:u_b]$ cannot contain $M$, we neglect these $\frac{n}{2}$ students on the right side of $M$.

            \textbf{1.2} $a[m_a+1]\geq b[m_b+1]$\\
            The median student $M$ is $b[m_b+1]$. Because $b[m_b+1] \geq b[m_b]$, there are $\frac{n}{2}$ students on the left side of $M$ ($b[l_b:m_b]$). Because $a[m_a+1]\geq b[m_b+1] \geq b[m_b] > a[m_a]$, there are $\frac{n}{2}$ students on $b[m_b+1]$ left side ($a[l_a:m_a]$). Therefore, there are $n$ students on  $b[m_b+1]$ left side. Also, because $b[m_b+1] \in b[m_b+1:u_b]$, $b[m_b+1]$, there are $\frac{n}{2}-1$ students on its right ($b[m_b+2:u_b]$). Because $b[m_b] \leq a[m_a+1]$, there are $\frac{n}{2}$ students on its right ($a[m_a+1:u_a]$). Thus, there are $n-1$ students on its right and $n$ on its left. Satisfying the definition of larger median student.  
        \item $a[m_a] > b[m_b]$\\
            This case is similar to case discussed above (symmetric case by switching a[] and b[]). The proof is basically the same by simply swapping $a$ and $b$. Here, we either neglect ranges $a[m_a+1:u_a], b[l_b:m_b]$ or we return $a[m_a+1]$
        \item $a[m_a] == b[m_a]$\\
            In this case, we find median student $M$. We consider $a[m_a]$ as $M$. There are $\frac{n}{2}-1$ students on its left ($a[l_a:m_a-1]$) and $\frac{n}{2}$ on its left ($b[l_b:m_b]$). There are $\frac{n}{2}$ students on its right ($a[m_a+1:u_a]$) and $\frac{n}{2}$ on its right ($b[m_b+1:u_b]$). Therefore, it is the desired median student by definition. 
\end{enumerate}
This is saying, the algorithm either neglects two ranges of students from both side of $s[]$ that have same size and don't contain median student or stops when we find desired student. $\square$

\textbf{Termination proof:} The algorithm, as proved in lemma, neglect same number of students from both side of $s[]$. This means that the searching range is strictly decreasing when we has a recursive call, in which we solve a smaller sub problem. There exists situations that end the recursive calls. Either we find students in the searching range on line 21 and 26 or the searching ranges is squeezed to size of 2 (2 desired median students) and return any one of them. Therefore, the algorithm terminates. $\square$ \\

\textbf{Theorem[Algorithm Correctness]:} If you call FindStudent($a[ ]$,$b[]$, $l_a$, $u_a$, $l_b$, $u_b$), it terminates, and afterwards, it returns an integer $i$ such that $n$ scores in $a[]$ and $b[]$ are no less than $i$, $n$ scores are no more than $i$.

\textbf{Proof:} by induction on $n$ (size of one of the array we are currently working on)

\textbf{Base Case:} 

n=1, trivially proved in Lemma.

n=2, we assume we have $a[1], a[2], b[1], b[2]$, $a[m_a] = a[1], b[m_b] = b[1]$. If $a[1] < b[1]$ and $a[2] < b[2]$, we keep searching on $a[2]$ and $b[1]$, both of which satisfies being median student in n=1 case. If $ a[1] < b[1]$ and $a[2] \geq b[2]$, we return $b[2]$ which satisfies the definition. In the symmetric situation, it is also trivially true. If $a[1] == b[1]$, $b[1]$ is on $a[1]$'s left side, a[2] and $b[2]$ on its right. Satisfied.

\textbf{Inductive Hypothesis:} Assume the theorem holds for $1,2,...,n-1$

\textbf{Inductive Step:} We get to assume that the algorithm works for all $a[],b[]$ size $1,2,...,n-1$, total number of elements from $2,4,...,2n-2$ (Strong induction hypothesis)
\\Size of recursive calls:
\begin{enumerate}
    \item $m_a-l_a+1+u_b-(m_b+1)+1\\= \lfloor\frac{l_a+u_a}{2}\rfloor-l_a+u_b-\lfloor\frac{l_b+u_b}{2}\rfloor+1 < u_a-l_a+r_b-l_b+2=2n$
    \item $u_a-(m_a+1)+1+m_b-l_b+1\\= u_a-\lfloor\frac{l_a+u_a}{2}\rfloor+\lfloor\frac{l_b+u_b}{2}\rfloor-l_b+1 < u_a-l_a+r_b-l_b+2=2n$
\end{enumerate}

The lemma tells us that when the size of two input array a[], b[] are all $n = 2q$ for all $q\in N^+$, the algorithm always neglect the subarrays that don't involve the desired median and squeeze the searching range to work on or find the correct median $M$. Since new searching range is composed by two smaller subarrays, we can use the inductive hypothesis on the recursive call that will terminate, and the result is the desired median. $\square$

\textbf{Running Time:}
Let $n$ be the size of one input array, we have total $2n$ students. 
Since comparisons and calculation on lines 15, 16, 17, 18 and 22 only takes $\Theta(1)$ time and there is only one recursive call on half of the size. Thus, we have the following recurrence relation: 
\[T(2n) = T(n) + \Theta(1) \Rightarrow T(n) = T(\frac{n}{2})+\Theta(1)\]
By the Master Theorem, we have 
\[T(n)=\Theta(\log{n})\]
\end{document}
