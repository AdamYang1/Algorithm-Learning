\documentclass{article}
\author{Shixiang (Adam) Yang}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\newcommand\mycommfont[1]{\footnotesize\ttfamily\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}

\SetKwInput{KwInput}{Input}                % Set the Input
\SetKwInput{KwOutput}{Output}              % set the Output
\date{September 23, 2022}
\title{CSCI270 - Assignment4}
% \graphicspath{{./media/}}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{tikz} 
\usepackage{amsfonts}
\usepackage{indentfirst}
\setlength\parindent{24pt}
\begin{document} \maketitle
\section{Problem 1}
This problem is mainly using Master Theorem to solve the recurrence relations.
\subsection{}
$a = 9, b = 3, k = 2, p = 0$

$n^{\log_b{a}} = n^{\log_3{9}} = n^2 = f(n)$

$T(n) = \Theta(f(n)*\log{n}) = \Theta(n^{\log_3{9}}*log^{0+1}{n}) = \Theta(n^2\log{n})$

\subsection{}

$a=10, b=5, k = 1/5$

$n^{\log_b{a}}=n^{\log_5{10}}$

Let $x = \log_5{10}, y = 1.5$
$5^x = 10, 5^y = 5^{3/2} = \sqrt{125} > 10$

Therefore, $x < y, n^{\log_5{10}} < n^{1.5} = f(n)$

$T(n) = \Theta(f(n)) = \Theta(n^{1.5})$

\subsection{}

$a=3,b=4,k=1/2$

$n^{\log_b{a}} = n^{\log_4{3}}$

Let $x=\log_4{3}, y = 1/2, 4^x = 3 > 4^y = 2$

Therefore, $x>y, n^{\log_4{3}} > \sqrt{n} = f(n)$

$T(n)=\Theta(n^{\log_4{3}})$

\subsection{}

In the first layer: $\Theta(n)$

In the second layer: $\Theta(n/3+2n/3)=\Theta(n)$

In the third layer:
$\Theta(n/9+2n/9+2n/9+4n/9)=\Theta(n)$

By drawing a recurrence tree, we can find out that each layer takes $\Theta(n)$.

Assume there are $k$ layers. We have: $n*(2/3)^k=1, k = \log_{3/2}{n}$.

$T(n) = \Theta(n\log_{\frac{3}{2}}{n})=\Theta(n \frac{\log{n}
}{\log{\frac{3}{2}}})=\Theta(n\log{n})$

\subsection{}
In the first layer: $\Theta(n)$

In the second layer: $\Theta(n/4+2/n) = \Theta(3n/4)$

In the third layer: $\Theta(n/16+n/8+n/8+n/4)=\Theta(9n/16)$

In the i-th layer:
$\Theta((\frac{3}{4})^{i-1}n)$

Assume there are $k$ layers, we have: $n/{2^k}=1, k = \log{n}$

$T(n)=\sum_{i=1}^{\log{n}}(\frac{3}{4})^{i-1}n=n*\frac{1-(3/4)^{\log{n}}}{1-3/4}$

Notice that \[c_5n \leq T(n) \leq \lim_{n \to -\infty}n\frac{1-(3/4)^{\log{n}}}{1-3/4}=4n\]

Therefore, the lower bound is $\Omega(n)$, the upper bound is $O(4n)=O(n)$.

$T(n) = \Theta(n)$

\section{Problem 2}
\subsection{Problem a}
We prove by contradiction. Assume that for $i\in [1,n-1]$, there is no such pair ($a_i, a_{i+1}$) that $a_i < a_{i+1}$ in $A$. That is, $\forall i\in[1,n+1]: a_i \geq a_{i+1}$ in $A$. Therefore, $a_1 \geq a_2 \geq a_3 ... \geq a_{n-1} \geq a_{n}, a_1 \geq a_n$. Because $a_1 < a_n$, contradiction! Therefore, there exists at least one desired pair in A. $\square$
\subsection{Problem b}
\begin{algorithm}[!ht]
\DontPrintSemicolon
\KwInput{$A[ ]$, lower bound $l$, upper bound $u$ (we only search $A[l:u]$)}
  \SetKwFunction{FSub}{Find} 
    \SetKwProg{Fn}{Def}{:}{} 
      \Fn{\FSub{$A[ ]$, $l$, $u$}}{ 
    \If{$l==u$}{
        return -1;  \tcp*{can't find a pair from a single element}
    } \Else{
          $m \leftarrow \lfloor\frac{u+l}{2}\rfloor$
          
          \If{$A[m] < A[m+1]$}{
            return $m$
          } \Else {
            \If{$A[l] \geq A[m]$}{
                return Find($A[], m+1, u$)
            } \Else{
                return Find($A[ ], l, m$)
            }
          }

    }
      }
    desiredPairIndex $\leftarrow$ Find($A[], 1,n$)
      \;

\caption{An algorithm finding a pair ($a_i < a_{i+1}$) and output index $i$}
\end{algorithm}

\textbf{Proof of Correctness:}
\\\textbf{Correctness:} The output is a pair ($a_i<a_{i+1}$) for $i\in [1,n-1]$ in A. Proven in problem a, an array A with $a_1 < a_n$ must has a pair ($a_i,a_{i+1}$) such that $a_i<a_{i+1}$ on $A[1:n]$.
\\From line 6 to 12, we explicitly choose the subarray $Sub[] = A[l:m]$ or $Sub[]=A[m+1:u]$ with size $p$ that satisfies $Sub[1] < Sub[p]$ to work on.
\\\textbf{Lemma:} if the input array A[l:u] has $A[l] < A[u], m=\lfloor \frac{l+u}{2}\rfloor$, there always exists a subarray  $Sub[] = A[l:m]$ or $Sub[]=A[m+1:u]$ with size $p$ that satisfies $Sub[1] < Sub[p]$ and contains the desired pair for the algorithm to find. In other words, the algorithm always choose the subarray that involves the desired pair.
\\\textbf{Proof of Lemma:} To prove the lemma, we always assume that the input array $A[]$ has at least two elements because the algorithm doesn't concern finding the subarray for the array that has only one element. When the array $A[]$ only has two elements, it means we have found the element since the $A[1]<A[2]$. WLOG, let's look at the array $A[]$ indexed from $1$ to $n$, $A[1] < A[n], n>1$. In this case, $l = 1, u = n, m=\lfloor \frac{l+u}{2}\rfloor$. There are three cases here:
\begin{enumerate}
    \item $A[m] < A[m+1]$: we don't need to concern about the subarray here since the algorithm will terminate once finding the desired pair.
    \item $A[m] \geq A[m+1]$ \textbf{and} $A[l] \geq A[m]$: because $A[m+1] \leq A[m] \leq A[l] < A[u]$, $A[m+1] < A[u]$. Therefore, the subarray $Sub[] = A[m+1:u]$ with size $p$ has $Sub[1] = A[m+1] < A[u] = Sub[p]$
    \item $A[m] \geq A[m+1]$ \textbf{and} $A[l] < A[m]$: the subarray $Sub[]=A[l:m]$ with size $p$ has $Sub[1] = A[l] < A[m] = Sub[p]$
\end{enumerate}
Therefore, when the size of $A[]$ is at least 2, either the algorithm terminates for finding desired pair or keeps working on a subarray $Sub[]$ that has the first element strictly less than the last element and contains the desired pair. Lemma Proved! The algorithm always picks the subarray that involves the desired pair.
\\\textbf{Theorem [Algorithm Correctness]:} If you call Find($A[ ], l, u$), it terminates, and afterwards, it returns a pair ($a_i<a_{i+1}$) for $i\in [1,n-1]$ in $A[l:u]$.
\\By induction on $n = u-l+1$ (size of the array that we are working on)
\\\textbf{Base Case:} n=1 (l==u), algorithm does nothing since there's only one element we are working on. We return null since there is no a pair.
\\\textbf{Inductive Hypothesis:} Assume that the algorithm works for all array size $1, 2, ..., n-1$
\\\textbf{Inductive Step:} We get to assume that algorithm works
for all array sizes 1, ..., n-1 (Strong induction hypothesis.) 
\\Sizes for recursive calls:
\begin{enumerate}
    \item $m-l+1 = \lfloor \frac{l+u}{2}\rfloor - l + 1 < u-l+1=n$
    \item $u-(m+1)+1 = u-\lfloor \frac{l+u}{2}\rfloor < u-l+1=n$
\end{enumerate}

The lemma tells us that when the size of input array $A$ is at least two, the algorithm always find the subarray that has the first element strictly less than the last element to work on. Because both subarrays are smaller and we only choose the subarray that contains the desired pair to work on, we can use the inductive hypothesis on choosen recursive call that will terminate, and the result is the desired pair. $\square$

\textbf{Running time analysis:}\\
Observing the algorithm, on each level recursion of size $n$ we has another recursive call of size $n/2$ and primitive operation (comparison and assignment) that takes $\Theta(1)$. Assume the running time of algorithm with input array size of n as $T(n)$. The recurrence relation is \[T(n)=T(n/2)+\Theta(1)\]
By master theorem, $a = 1, b = 2, \log_b{a} = \log_2{1} = 0 < 1 = f(n)$. The running time is: \[T(n) = n^{\log_b{a}}*\log{n} = n^0*\log{n} = \log{n}\]

\section{Problem 3}
\begin{algorithm}[!ht]
\DontPrintSemicolon
\KwInput{$a[ ]$,$b[]$, $l_a$, $u_a$, $l_b$, $u_b$ (indexed from 1 to n)}
  \SetKwFunction{FSub}{FindStudent} 
    \SetKwProg{Fn}{Def}{:}{} 
      \Fn{\FSub{$a[ ]$,$b[]$, $l_a$, $u_a$, $l_b$, $u_b$}}{ 
      \tcc{we only work on $a[l_a:u_a]$ and $b[l_b:u_b]$}
        $m_a \leftarrow \lfloor\frac{u_a+l_a}{2}\rfloor$
        
        $m_b \leftarrow \lfloor\frac{u_b+l_b}{2}\rfloor$
        
        \If{$a[m_a] < b[m_b]$}{
            \If{$a[m_a+1]<b[m_b+1]$}{
                return FindStudent($a[],b[], m_a+1, u_a, l_b, m_b$)
            } \Else {
                return $b[m_b+1]$
            }
        } \Else {
            \If{$a[m_a+1]>b[m_b+1]$} {
                return FindStudent($a[],b[],l_a, u_a,m_b+1, u_b$)
            } \Else {
                return $a[m_a+1]$
            }
        }
    }
    
    desiredMiddleNumber $\leftarrow$ FindStudent($a[],b[],1,n,1,n$)
      \;
\caption{An algorithm finding "most middle" student}
\end{algorithm}
\textbf{Proof of Correctness:}\\
\textbf{Correctness:} The output is a student $i$ (out
of the $2n$ total) such that at least $n$ students had scores no higher than $i$, and at least $n$ students had scores no lower than $i$. In this question, we assume $n$ is always even. Therefore, $m = \lfloor\frac{u+l}{2}\rfloor$, $a[l_a:m_a], a[m_a+1:u_a], b[l_b:m_b], a[m_b+1:u_b]$ all contain exactly $n/2$ students. \\
\textbf{Lemma:} The subarrays we choose from $a[], b[]$ of the same size n to work on involve the desired median $(n>2)$. When $n=2$, we can easily solve the problem in $O(1)$. We define $l_a, u_a$ as the lower bound and upper bound of array $a[]$'s range that algorithm is working on, $l_b, u_b$ as lower bound and upper bound of array $b[]$'s range that algorithm is working on.
\\\textbf{Proof of Lemma:} 
Given two sorted array $a[l_a: u_a], b[l_b:u_b]$ both of size $n$ ($u_a-l_a = u_b-l_b=n$). We have four scenarios to deal with \begin{enumerate}
    \item $a[m_a] < b[m_b]$ 
     
            \textbf{1.1} \textbf{$a[m_a+1]<b[m_b+1]$}\\
            The median student $M$ must lie on $a[m_a+1:u_a]$ or $b[l_b:m_b]$.
            \\\textbf{1) It cannot lie on }$a[l_a:m_a]$\\
             This can be proved by contradiction. Assume $M$ is in $a[l_a:m_a]$. Thus, $M$ is at most no less than $\frac{n}{2}$ students on $a[l_a:m_a]$. Meanwhile, because $a[m_a]<b[m_b]$, $M$ is at most no less than $\frac{n}{2}-1$ students on $b[l_b:m_b-1]$. (If $m_b-1 < l_b$, we have nothing on this range, which trivially makes $M$ also contradicts the definition.) Therefore, $M$ is at most no less than at most $n-1$ students. By definition, the median is at least no less than $n$ scores. Contradiction! Therefore, $M \geq a[m_a]+1$, the desired median mustn't exist in $a[l_a:m_a]$.
            \\\textbf{2) It cannot lie on} $b[m_b+1: u_b]$.\\
            This can be also proved by contradiction. Assume the median student $M$ is in $b[m_b+1: u_b]$. Thus, $M$  is at most no greater than $\frac{n}{2}$ students on $b[m_b+1: u_b]$. Meanwhile, because $a[m_a+1] < b[m_b+1]$, $M$ is at most no grater than $\frac{n}{2}-1$ students on $a[m_a+2:u_a]$. (When $m_a+2 < u_a$, we have nothing on this range, which trivially makes $M$ contradicts the definition.) Therefore, $M$ is at most no greater than at most $n-1$ students, which contradicts the definition. Therefore, the desired median cannot exist in $b[m_b+1:u_b]$.
        
        Therefore, the algorithm neglect the ranges that cannot contain desired student $M$ and work on ranges $a[m_a+1:u_a]$ and $b[l_b,m_b]$, both of same size of $n/2$ and contain desired median student $M$.

            \textbf{1.2} $a[m_a+1]\geq b[m_b+1]$\\
            The median student $M$ is $b[m_b+1]$. Because $b[m_b+1] \geq b[m_b]$, it is at least no less than $n/2$ students on $b[l_b:m_b]$. Because $a[m_a+1]\geq b[m_b+1] \geq b[m_b] > a[m_a]$, $b[m_b+1]$ is also at least no less than $n/2$ students on $a[l_a:m_a]$. Therefore, it is no less than at least Because $b[m_b+1] \in b[m_b+1:u_b]$, $b[m_b+1]$ is no greater than $n/2$ students on $b[m_b+1:u_b]$. Because 
    
    
\end{enumerate}
\textbf{Theorem[Algorithm Correctness]:} If you call FindStudent($a[ ]$,$b[]$, $l_a$, $u_a$, $l_b$, $u_b$), it terminates, and afterwards, it returns an integer $i$ such that $n$ scores in $a[]$ and $b[]$ are no less than $i$, $n$ scores are no more than $i$.\\
\textbf{Proof:} by induction on $n$ (total size of one of the array we are currently working on)
\\\textbf{Base Case:} n=1, Algorithm sorts two numbers and return the median, which is the smaller number that satisfies.
\\\textbf{Inductive Hypothesis:} Assume the theorem holds for $1,2,...,n-1$
\\\textbf{Inductive Step:} We get to assume that the algorithm works for all $a[],b[]$ size $1,2,...,n-1$, total number of elements from $2,4,...,2n-2$ (Strong induction hypothesis)
\\Size of recursive calls:
\begin{enumerate}
    \item $m_a-l_a+1+u_b-(m_b+1)+1\\= \lfloor\frac{l_a+u_a}{2}\rfloor-l_a+u_b-\lfloor\frac{l_b+u_b}{2}\rfloor+1 < u_a-l_a+r_b-l_b+2=2n$
    \item $u_a-(m_a+1)+1+m_b-l_b+1\\= u_a-\lfloor\frac{l_a+u_a}{2}\rfloor+\lfloor\frac{l_b+u_b}{2}\rfloor-l_b+1 < u_a-l_a+r_b-l_b+2=2n$
\end{enumerate}

The lemma tells us that when the size of two input array a[], b[] is larger than 2, the algorithm always find the subarray that involves the desired median to work on. Since both subarrays are smaller and we only choose the subarray that contains the desired median to work on, we can use the inductive hypothesis on the choosen recursive call that will terminate, and the result is the desired median.
\end{document}
