\documentclass[openany]{article}

%Typesetting and language
\usepackage[american]{babel}
\usepackage[T1]{fontenc}
\usepackage{charter}
\usepackage{enumitem}
\usepackage{hyperref}

%Symbols
\usepackage{amssymb, amsmath, amsthm, bm}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{marvosym}
\usepackage{MnSymbol}

%Colors & graphics
\usepackage[dvipsnames]{xcolor}
\usepackage{pgfplots}
\usepackage[numbered,framed]{matlab-prettifier}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\usepackage[object=vectorian]{pgfornament}
\usepackage{wrapfig}
\usepackage{varwidth}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{caption}
\usepackage{float}
\usepackage{geometry}
\usepackage{ulem}
\usepackage[most]{tcolorbox}
\usepackage{array}

\setlength{\parindent}{0pt}

\makeatletter
\g@addto@macro\bfseries{\boldmath}
\makeatother


\renewcommand{\Re}{\mathfrak{Re}}
\renewcommand{\Im}{\mathfrak{Im}}

\geometry{left=2cm,right=2cm,bottom=2cm,top=2cm}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\sectionmark}[1]{\markright{\arabic{section} - #1}}
\cfoot{\thepage}
\lhead{CS270}
\chead{HW9}
\rhead{Adam Yang}
\renewcommand{\headrulewidth}{1pt}


\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Fix}{Fix}
\DeclareMathOperator{\Stab}{Stab}
\DeclareMathOperator{\cov}{cov}
\DeclareMathOperator*{\esssup}{ess\,sup}
\DeclareMathOperator{\corr}{corr}
\DeclareMathOperator{\lik}{lik}
\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax}

\newcommand{\niceline}[2]{%
		\nointerlineskip \vspace{.5\baselineskip}\hspace{\fill}
		{\color{#1}
				\resizebox{0.5\linewidth}{2ex}
				{{%
								{\begin{tikzpicture}
										\node  (C) at (0,0) {};
										\node (D) at (9,0) {};
										\path (C) to [ornament=#2] (D);
										\end{tikzpicture}}}}}%
		\hspace{\fill}
		\par\nointerlineskip \vspace{.5\baselineskip}
}

\definecolor{darkViolet}{HTML}{9400D3}
\newcommand{\sweetline}{%
		\noindent
		\begin{center}
				{\color{darkViolet}
						\resizebox{0.5\linewidth}{1ex}
						{{%
										{\begin{tikzpicture}
												\node  (C) at (0,0) {};
												\node (D) at (9,0) {};
												\path (C) to [ornament=85] (D);
												\end{tikzpicture}}}}}%
		\end{center}
}

\definecolor{remarkPurple}{HTML}{8346FF}
\definecolor{defBlue}{HTML}{0673FF}
\definecolor{exPurple}{HTML}{FF8710}

%THEOREM
\newtcbtheorem[auto counter,number within=section]{theorem}{Theorem}%
{enhanced,colback=white, breakable,frame empty,interior empty,colframe=cyan!50!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=cyan!15!white,
				borderline={0.5mm}{0mm}{cyan!15!white},
				borderline={0.5mm}{0mm}{cyan!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{thm}

%PROPOSITION
\newtcbtheorem[use counter from=theorem]{proposition}{Proposition}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prop}

%DEFINITION
\newtcbtheorem[use counter from=theorem]{definition}{Definition}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{def}

%COROLLARY
\newtcbtheorem[use counter from=theorem]{corollary}{Corollary}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{cor}

%REMARK
\newtcbtheorem[no counter]{remark}{Remark}%
{detach title, colback=white,enhanced ,breakable,frame empty, interior empty, fonttitle=\bfseries, coltitle=Violet, before upper={\tcbtitle.\quad},
				borderline west={0.5mm}{0mm}{remarkPurple!40!white},
				borderline west={0.5mm}{0mm}{remarkPurple!60!white,dashed}}{remark}

%LEMMA
\makeatletter
\newtcbtheorem[number within = tcb@cnt@theorem]{lemma}{Lemma}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=orange!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=orange!20!white,
				borderline={0.5mm}{0mm}{orange!20!white},
				borderline={0.5mm}{0mm}{orange!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{lemma}
\makeatother


%PROOF
%%{enhanced,breakable,frame empty,interior empty,colframe=remarkPurple!75!white, top=8mm,
%	coltitle=black,fonttitle=\bfseries,colbacktitle=remarkPurple!20!white,
%	borderline={0.5mm}{0mm}{remarkPurple!20!white},
%	borderline={0.5mm}{0mm}{remarkPurple!50!white,dashed},
%	attach boxed title to top left={yshift=-4mm},
%	boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prf}


\tcolorboxenvironment{proof}{% amsthm' 
				blanker,breakable,left=5mm,
				before skip=10pt,after skip=10pt,
				borderline west={0.5mm}{0pt}{cyan!40},
				borderline west={0.5mm}{0pt}{remarkPurple!10, dashed}}

%PROBLEM
\newtcbtheorem[auto counter]{problem}{Problem}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=cyan!50!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=cyan!20!white,
				borderline={0.5mm}{0mm}{cyan!20!white},
				borderline={0.5mm}{0mm}{cyan!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prob}

%EXAMPLE
%\newtcbtheorem[use counter from=problem]{example}{Example}%
%{enhanced,breakable,colback=white,frame empty,interior empty,colframe=remarkPurple!50!white, top=8mm,
%		coltitle=black,fonttitle=\bfseries,colbacktitle=remarkPurple!30!white,
%		borderline={0.5mm}{0mm}{remarkPurple!30!white},
%		borderline={0.5mm}{0mm}{remarkPurple!30!white,dashed},
%		attach boxed title to top left={yshift=-4mm},
%		boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{ex}


\newtcbtheorem[use counter from=theorem]{example}{Example}%
{detach title, colback=white,enhanced ,breakable,frame empty, interior empty, fonttitle=\bfseries, coltitle=black, before upper={\tcbtitle.\quad},
		borderline west={0.5mm}{0mm}{remarkPurple!30!white},
		borderline ={0.5mm}{0mm}{remarkPurple!30!white}}{example}

%SOLUTION
\newtcbtheorem[no counter]{solution}{Solution}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=green!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=green!20!white,
				borderline={0.5mm}{0mm}{green!20!white},
				borderline={0.5mm}{0mm}{green!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{sol}
\definecolor{realPurple}{HTML}{AA05F9}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
				style=Matlab-editor,
				language=C,
				aboveskip=3mm,
				belowskip=3mm,
				xleftmargin=3mm,
				showstringspaces=false,
				columns=flexible,
				frame=none,
				basicstyle={\small\ttfamily},
				numberstyle=\tiny\color{gray},
				keywordstyle=\color{blue},
				commentstyle=\color{dkgreen},
				stringstyle=\color{mauve},
				breaklines=true,
				breakatwhitespace=true,
				mlshowsectionrules = true,
				tabsize=3,
                    escapechar = ~,
				backgroundcolor=\color{cyan!5}
}

\newcommand\mmybox[2][fill=cyan!20]{%
    \tikz[baseline]\node[%
        inner ysep=0pt, 
        inner xsep=2pt, 
        anchor=text, 
        rectangle, 
        rounded corners=1mm,
        #1] {\strut#2};%
}


\def\changemargin#1#2{\list{}{\rightmargin#2\leftmargin#1}\item[]}
\let\endchangemargin=\endlist

\linespread{1.4}



% MAIN DOC
\begin{document}

\title{HW 9}
\author{Adam Yang}
% \date{\today}
\maketitle




\section*{Problem1}

For convenience, name the algorithm to solve \textbf{Decision} problem as $D$, the algorithm to solve \textbf{Optimization} problem as $Opt$, and the algorithm to solve \textbf{Search} problem as $S$.

$D(C)$ takes an input of a integer value and returns if there is any $s-t$ cut whose capacity value is at most $C$.

$Opt(G)$ takes an input of a graph $G$ and return the smallest capacity value.

$S(G)$ takes an input of a graph $G$ and return the min-cut $(S, \Bar{S})$.

\subsection*{Problem a}

\begin{proof}{}{DECISION-OPTIMIZATION polynomial-time equivalence}
    \subsubsection*{1. DECISION is polynomial time reducible to OPTIMIZATION}

Suppose $Opt(G)$ finds the smallest capacity value of any $s-t$ cut, denote it as $C'$. In order to find out if there is an $s-t$ cut $(S, \Bar{S})$ with capacity at most $C$, we need to compare $C$ and $C'$. If $C' \leqslant C$, then our answer for \textbf{Decision} problem is "yes". If $C' > C$, then our answer for \textbf{Decision} problem is "no" because the capacity can never be less than $C'$. Since in $D$, we use $Opt(G)$ once and do a $\mathcal{O}(1)$ comparison, DECISION is polynomial time reducible to OPTIMIZATION 

\subsubsection*{2. OPTIMIZATION is polynomial time reducible to DECISION}

[Proof required]
  
Suppose $D$ returns if an $s-t$ cut $(S,\Bar{S})$ with capacity at most $C$ exists. We can first find out the largest possible capacity $C^+$ by summing the capacity of all the positive edges. Similarly, we can find out the smallest possible capacity $C^-$ by summing the capacity of all edges with negative capacities. We can have an array to store the information for capacities from $C^-$ to $C^+$, which is $\mathcal{O}(n)$ with total $C^+-C^-+1$ elements. With start index $0$ and ending index $C^+-C^-$, we can implement binary-search-like algorithm to determine the smallest capacity. Notice that if we find a capacity value $C$ where $D(C)$ is true but $D(C-1)$ is false, we find the smallest capacity of any $s-t$ cut because no $s-t$ cut has lower capacity than $C$. 

\textbf{The running time:} Calculating $C^-$ and $C^+$ requires $\mathcal{O}(|E|)$. Notice that the running time is $\mathcal{O}(log n)$ for binary search. Since $C^++|C^-|+1 = \mathcal{O}(n)$, there are $\mathcal{O}(2^n)$ elements in terms of the number of bits. Therefore, the binary search which takes $\mathcal{O}(log{2^n}) = \mathcal{O}(n)$ is linear in terms of numbers of bit. Notice that the arithmetic operations in the algorithm take $\mathcal{O}(1)$, therefore the running time of this $Opt(G)$ with $D$ is weakly polynomial. [The algorithm is below]

\begin{proof}[Algorithm]{}
		\renewcommand{\qedsymbol}{}
		Algorithm $Opt(G)$ with "API" $D(G)$
		\begin{lstlisting}[basicstyle=\fontsize{8}{9}\selectfont\ttfamily]
~$G(V,E)$~ := input Graph  ~$s$~ := source node  ~$t$~ := tank node
~$D$~ := Decision Problem API  ~$C^-$~ := ~$\sum_{e\in E:c_e\leqslant 0 }c_e$~ ~$C^+$~ := ~$\sum_{e\in E:c_e>0 0 }c_e$~
int L = 0; int R = ~$|C^-|+C^+$~;
while(R>L){
    int M = L + (R-L)/2;
    if(D(M) == true) R = M;
    else L=M+1;
}
return R
		\end{lstlisting} 
\end{proof}

Therefore,   OPTIMIZATION is polynomial time reducible to DECISION.
Now that \textbf{Optimization problem} and \textbf{Decision problem} can be mutually polynomial-time reducible, they are polynomial-time equivalent.
\end{proof}

\subsection*{Problem b}
\begin{proof}{}{OPTIMIZATION-SEARCH polynomial-time equivalence}
    
\subsubsection*{1. OPTIMIZATION is polynomial time reducible to SEARCH}
Suppose $S(G)$ finds the min-cut $(S,\Bar{S})$ for the graph $G$ that minimizes $c(S,\Bar{S})$. By the definition of min-cut, the value of $c(S,\Bar{S})$ is already the smallest capacity value of any $s-t$ cut. Therefore, since in $Opt(G)$ we find min-cut $(S,\Bar{S})$ using $S(G)$ and calculate the capacity $c(S,\Bar{S})$ in $\mathcal{O}(|E|)$,  OPTIMIZATION is polynomial time reducible to SEARCH.

\subsubsection*{2. SEARCH is polynomial time reducible to OPTIMIZATION} 
\begin{proof}[Algorithm]{}
		\renewcommand{\qedsymbol}{}
		Algorithm $S(G)$ with "API" $Opt(G)$
		\begin{lstlisting}[basicstyle=\fontsize{8}{9}\selectfont\ttfamily]
Inputs:
~$G(V,E)$~ := input Graph  ~$s$~ := source node  ~$t$~ := tank node
~$Opt$~ := Decision Problem API
Initializations:
~$S$~ = ~$\{s\}$~
~$\Bar{S}$~ = ~$\{t\}$~
~$C$~ = ~$Opt(G)$~
for each vertex ~$v\in V, v \neq s, v \neq t$~:
    if there exists and edge ~$e(s,v)$~:
        set ~$c_e = \infty$~
    else:
        construct an edge ~$e(s,v)$~ with capacity ~$c_e=\infty$~
    if(~$Opt(G)$~ == C): // min cut stays the same
        ~$S \leftarrow S \cup \{v\}$~
    else:
        ~$\Bar{S} \leftarrow \Bar{S} \cup \{v\}$~
    disregard all the changes made // ~$G$~ goes back to the original graph
return ~$(S, \Bar{S})$~
    
		\end{lstlisting} 
\end{proof}
For graph $G$, $Opt(G)$ gives us the minimum cut capacities value for some to-be-discovered $s-t$ cut $(S, \Bar{S})$, denoted as $C$. Notice that it is possible that we have multiple minimum cuts with same capacities value. In the following, the graph after operation of \texttt{set} $c_e = \infty$ or \texttt{construct an edge} $e(s,v)$ with capacity $c_e = \infty$ will be denoted as $G'$ for convenience. Also, the operation on edge $(s,v)$ refers to either make the capacity to $\infty$ or add a new edge with $\infty$ capacity for a vertex $v\in V, v\neq s, t$ for convenience.

\textbf{Observation:} Focusing on a cut $(S,\Bar{S})$ with capacity $Opt(G) = C$.

If a node $v\in S$, the operation on $(s,v)$ not change the capacity of $(S,\Bar{S})$. Therefore, if $Opt(G) = Opt(G')$ after operation on $(s,v)$, $v \in S$. If a node $v \in \Bar{S}$, the operation increase the capacity of original cut $(S,\Bar{S})$ since the cut allows more flow to pass through, meaning the new cut for $(S,\Bar{S})$ will be larger than $C$. Thus, if the capacity of this cut become larger after the operation, $v \in \Bar{S}$.

(1) There exists a unique min cut $(S,\Bar{S})$ with capacity $C$ to SEARCH.

As observed above, if the capacity of a cut doesn't change after operation on $(s,v)$, we can say that $v\in S$ for that cut. Since there exists a unique min cut for $G$, $Opt(G)$ will return the capacities of that cut. If the operation on $(s,v)$ doesn't change the capacity of that unique min cut and thus $Opt(G) = Opt(G')$, we can say that $v\in S$. Nevertheless, if the cut capacity increases, $Opt(G) < Opt(G')$ because every other cut are strictly larger than original cut $(S,\Bar{S})$ and the cut capacity increase. Thus, we can say that $v \in \Bar{S}$ for the cut. Thus the output of $Opt(G)$ is the min cut $(S,\Bar{S})$.

(2) There exists multiple min $s-t$ cuts $(S_1,\Bar{S_1}), ... , (S_k,\Bar{S_k})$. In this part of discussion, $i,j \in [1,k], i\neq j, k \geqslant 1$. 

For a node $v$ in $G$, if the operation on $(s,v)$ leads to $Opt(G') \geqslant Opt(G)$, we can say that $\forall (S_i, \Bar{S_i}): v \in \Bar{S_i}$ because the operation allows more flow to pass through all $k$ potential min cuts. Since $\forall (S_i, \Bar{S_i}): v\in \Bar{S_i}$, we add $v$ to $\Bar{S}$ (line 16). If the operation on $(s,v)$ doesn't change $Opt(G)$, this means that $v$ is in $S_i$ some other valid min cut $(S_i,\Bar{S_i})$. We add such $v$ to $S$ (line 14). By loop through all nodes (all cuts at the same time), we have $S = \bigcup_{i=1}^{k}S_i$ and $\Bar{S} = \bigcup_{i=1}^{k}\Bar{S_i}$. Therefore, by proving that the union of min cuts are still min cut we can prove our output $(S,\Bar{S})$ is a min cut.

As discussed in lecture, at termination of Ford-Fulkerson, there is no more $s-t$ path in the residual graph. This means that every edge that crosses the min $s-t$ cut has no residual value. So, min cut $\Rightarrow$ are edges crosses the cut are filled. Also, if for a cut, every edge crosses that cut is filled, this means there is no $s-t$ path and thus FF algorithm will terminates and return the cut as the min cut. Thus, a $s-t$ cut is min cut if and only if its capacity with respect to the residual graph is zero.

WLOG, focus on two min cuts $(S_i,\Bar{S_i})$ and $(S_j, \Bar{S_j})$. Every outflow edge from $S_i$ and $S_j$ is filled. Therefore, every outflow edge from $S_i \cup S_j$ comes from $S_i$ or $S_j$. Since min cut $\Leftrightarrow$ edges crossing the cut are filled, $(S_i \cup S_j, \Bar{S_i} \cup \Bar{S_j})$ is also a min cut. Therefore, $(S,\Bar{S}) = (\bigcup_{i=1}^{k}{S_i},\bigcup_{i=1}^{k}\Bar{S_i})$ is also the min cut. This concludes the proof.



% where $|S_1| \leqslant |S_2| \leqslant ... \leqslant |S_k|$.


\end{proof}


\section*{Problem2}
\subsubsection*{Problem a}
In the same scenario, we can convert the problem into a "natural" decision problem: "can the difference $\Delta$ between the total skill of the most skilled team and the least skilled team be at most (less than or equal to) a value $D$." 

\textbf{Certificate:} an classroom of $n$ people, a collection of $k$ teams (each with $n/k$ people), each with student has $s_i$ integer skill value.

\textbf{Certifier:} check if this is the correct collection of $k$ teams, calculate the skill difference $\Delta$ between the maximum team and the minimum team, and compare it with $D$.

The certifier of this problem needs (1) calculate the total score for each team, it requires $\mathcal{O}(n)$ for looping all $n$ students. (2) loop through all $k$ groups and store the $\mathbf{\max}$ and $\mathbf{\min}$ in $\mathcal{O}(k)$ (3) compute the difference $\Delta = \mathbf{\max} - \mathbf{\min}$ (4) then compare $\Delta$ with $D$. If $\Delta < D$, output "yes", else "no". Since the certifier requires $\mathcal{O}(n+k)$, and comparison between two integers is easy, the converted decision problem is in \textbf{NP}.

\subsubsection*{Problem b}
In the same scenario, we can convert the problem into a "natural" decision problem: "can the a set $E$ of undirected edges such that for each of the cuts $(S_i, \Bar{S_i})$, the number of edges it cuts in the graph $G=(V, E)$ is at most $C$.

\textbf{Certificate:} a set $E$ of undirected edges on $G$

\textbf{Certifier:} check if for all cut $(S_i,\Bar{S_i})$, the number of edges it cuts in $G=(V,E)$ is at most $C$

The certifier of this problem needs (1) loop through all $k$ possible cuts, it requires $\mathcal{O}(k)$ times of iterations (2) check the cut capacity for each cut $(S_i, \Bar{S_i})$, each of which requires $\mathcal{O}(|E|)$. Since the certifier requires $\mathcal{O}(k|E|)$, and the comparison between two values is easy, the converted decision problem is in \textbf{NP}.

\section*{Problem3}
\subsection*{Problem a}
Can SOKOBAN be solved with at most $C$ steps ($C$ is an integer).

\subsection*{Problem b}
A sequence of move of the character

\subsection*{Problem c}
Follow the sequence of move, check whether or not all boxes are put into the destination, and sees if the steps of the move in the sequence is at most (less than or equal) $C$.


\section*{Problem4}
\subsection*{Problem a}

\end{document}
