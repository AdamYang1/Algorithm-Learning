\documentclass[openany]{article}

%Typesetting and language
\usepackage[american]{babel}
\usepackage[T1]{fontenc}
\usepackage{charter}
\usepackage{enumitem}
\usepackage{hyperref}

%Symbols
\usepackage{amssymb, amsmath, amsthm, bm}
\usepackage{mathrsfs}
\usepackage{mathtools}
\usepackage{marvosym}
\usepackage{MnSymbol}

%Colors & graphics
\usepackage[dvipsnames]{xcolor}
\usepackage{pgfplots}
\usepackage[numbered,framed]{matlab-prettifier}
\usepackage{pgfplots}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{arrows.meta}
\usepackage[object=vectorian]{pgfornament}
\usepackage{wrapfig}
\usepackage{varwidth}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{caption}
\usepackage{float}
\usepackage{geometry}
\usepackage{ulem}
\usepackage[most]{tcolorbox}
\usepackage{array}

\setlength{\parindent}{0pt}

\makeatletter
\g@addto@macro\bfseries{\boldmath}
\makeatother


\renewcommand{\Re}{\mathfrak{Re}}
\renewcommand{\Im}{\mathfrak{Im}}

\geometry{left=2cm,right=2cm,bottom=2cm,top=2cm}

\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\sectionmark}[1]{\markright{\arabic{section} - #1}}
\cfoot{\thepage}
\lhead{CS270}
\chead{HW9}
\rhead{Adam Yang}
\renewcommand{\headrulewidth}{1pt}


\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\im}{im}
\DeclareMathOperator{\var}{var}
\DeclareMathOperator{\Orb}{Orb}
\DeclareMathOperator{\Fix}{Fix}
\DeclareMathOperator{\Stab}{Stab}
\DeclareMathOperator{\cov}{cov}
\DeclareMathOperator*{\esssup}{ess\,sup}
\DeclareMathOperator{\corr}{corr}
\DeclareMathOperator{\lik}{lik}
\DeclareMathOperator*{\argmin}{argmin}
\DeclareMathOperator*{\argmax}{argmax}

\newcommand{\niceline}[2]{%
		\nointerlineskip \vspace{.5\baselineskip}\hspace{\fill}
		{\color{#1}
				\resizebox{0.5\linewidth}{2ex}
				{{%
								{\begin{tikzpicture}
										\node  (C) at (0,0) {};
										\node (D) at (9,0) {};
										\path (C) to [ornament=#2] (D);
										\end{tikzpicture}}}}}%
		\hspace{\fill}
		\par\nointerlineskip \vspace{.5\baselineskip}
}

\definecolor{darkViolet}{HTML}{9400D3}
\newcommand{\sweetline}{%
		\noindent
		\begin{center}
				{\color{darkViolet}
						\resizebox{0.5\linewidth}{1ex}
						{{%
										{\begin{tikzpicture}
												\node  (C) at (0,0) {};
												\node (D) at (9,0) {};
												\path (C) to [ornament=85] (D);
												\end{tikzpicture}}}}}%
		\end{center}
}

\definecolor{remarkPurple}{HTML}{8346FF}
\definecolor{defBlue}{HTML}{0673FF}
\definecolor{exPurple}{HTML}{FF8710}

%THEOREM
\newtcbtheorem[auto counter,number within=section]{theorem}{Theorem}%
{enhanced,colback=white, breakable,frame empty,interior empty,colframe=cyan!50!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=cyan!15!white,
				borderline={0.5mm}{0mm}{cyan!15!white},
				borderline={0.5mm}{0mm}{cyan!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{thm}

%PROPOSITION
\newtcbtheorem[use counter from=theorem]{proposition}{Proposition}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prop}

%DEFINITION
\newtcbtheorem[use counter from=theorem]{definition}{Definition}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{def}

%COROLLARY
\newtcbtheorem[use counter from=theorem]{corollary}{Corollary}%
{enhanced,colback=white,breakable,frame empty,interior empty,colframe=defBlue!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=defBlue!20!white,
				borderline={0.5mm}{0mm}{defBlue!20!white},
				borderline={0.5mm}{0mm}{defBlue!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{cor}

%REMARK
\newtcbtheorem[no counter]{remark}{Remark}%
{detach title, colback=white,enhanced ,breakable,frame empty, interior empty, fonttitle=\bfseries, coltitle=Violet, before upper={\tcbtitle.\quad},
				borderline west={0.5mm}{0mm}{remarkPurple!40!white},
				borderline west={0.5mm}{0mm}{remarkPurple!60!white,dashed}}{remark}

%LEMMA
\makeatletter
\newtcbtheorem[number within = tcb@cnt@theorem]{lemma}{Lemma}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=orange!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=orange!20!white,
				borderline={0.5mm}{0mm}{orange!20!white},
				borderline={0.5mm}{0mm}{orange!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{lemma}
\makeatother


%PROOF
%%{enhanced,breakable,frame empty,interior empty,colframe=remarkPurple!75!white, top=8mm,
%	coltitle=black,fonttitle=\bfseries,colbacktitle=remarkPurple!20!white,
%	borderline={0.5mm}{0mm}{remarkPurple!20!white},
%	borderline={0.5mm}{0mm}{remarkPurple!50!white,dashed},
%	attach boxed title to top left={yshift=-4mm},
%	boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prf}


\tcolorboxenvironment{proof}{% amsthm' 
				blanker,breakable,left=5mm,
				before skip=10pt,after skip=10pt,
				borderline west={0.5mm}{0pt}{cyan!40},
				borderline west={0.5mm}{0pt}{remarkPurple!10, dashed}}

%PROBLEM
\newtcbtheorem[auto counter]{problem}{Problem}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=cyan!50!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=cyan!20!white,
				borderline={0.5mm}{0mm}{cyan!20!white},
				borderline={0.5mm}{0mm}{cyan!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{prob}

%EXAMPLE
%\newtcbtheorem[use counter from=problem]{example}{Example}%
%{enhanced,breakable,colback=white,frame empty,interior empty,colframe=remarkPurple!50!white, top=8mm,
%		coltitle=black,fonttitle=\bfseries,colbacktitle=remarkPurple!30!white,
%		borderline={0.5mm}{0mm}{remarkPurple!30!white},
%		borderline={0.5mm}{0mm}{remarkPurple!30!white,dashed},
%		attach boxed title to top left={yshift=-4mm},
%		boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{ex}


\newtcbtheorem[use counter from=theorem]{example}{Example}%
{detach title, colback=white,enhanced ,breakable,frame empty, interior empty, fonttitle=\bfseries, coltitle=black, before upper={\tcbtitle.\quad},
		borderline west={0.5mm}{0mm}{remarkPurple!30!white},
		borderline ={0.5mm}{0mm}{remarkPurple!30!white}}{example}

%SOLUTION
\newtcbtheorem[no counter]{solution}{Solution}%
{enhanced,breakable,colback=white,frame empty,interior empty,colframe=green!75!white, top=8mm,
				coltitle=black,fonttitle=\bfseries,colbacktitle=green!20!white,
				borderline={0.5mm}{0mm}{green!20!white},
				borderline={0.5mm}{0mm}{green!50!white,dashed},
				attach boxed title to top left={yshift=-4mm},
				boxed title style={sharp corners=east,boxrule=1pt},varwidth boxed title}{sol}
\definecolor{realPurple}{HTML}{AA05F9}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
				style=Matlab-editor,
				language=C,
				aboveskip=3mm,
				belowskip=3mm,
				xleftmargin=3mm,
				showstringspaces=false,
				columns=flexible,
				frame=none,
				basicstyle={\small\ttfamily},
				numberstyle=\tiny\color{gray},
				keywordstyle=\color{blue},
				commentstyle=\color{dkgreen},
				stringstyle=\color{mauve},
				breaklines=true,
				breakatwhitespace=true,
				mlshowsectionrules = true,
				tabsize=3,
                    escapechar = ~,
				backgroundcolor=\color{cyan!5}
}

\newcommand\mmybox[2][fill=cyan!20]{%
    \tikz[baseline]\node[%
        inner ysep=0pt, 
        inner xsep=2pt, 
        anchor=text, 
        rectangle, 
        rounded corners=1mm,
        #1] {\strut#2};%
}


\def\changemargin#1#2{\list{}{\rightmargin#2\leftmargin#1}\item[]}
\let\endchangemargin=\endlist

\linespread{1.4}



% MAIN DOC
\begin{document}

\title{HW 9}
\author{Adam Yang}
% \date{\today}
\maketitle




\section*{Problem1}

For convenience, name the algorithm to solve \textbf{Decision} problem as $D$, the algorithm to solve \textbf{Optimization} problem as $Opt$, and the algorithm to solve \textbf{Search} problem as $S$.

$D(C)$ takes an input of a integer value and returns if there is any $s-t$ cut whose capacity value is at most $C$.

$Opt(G)$ takes an input of a graph $G$ and return the smallest capacity value.

$S(G)$ takes an input of a graph $G$ and return the min-cut $(S, \Bar{S})$.

\subsection*{Problem a}

\begin{proof}{}{DECISION-OPTIMIZATION polynomial-time equivalence}
    \subsubsection*{1. DECISION is polynomial time reducible to OPTIMIZATION}

Suppose $Opt(G)$ finds the smallest capacity value of any $s-t$ cut, denote it as $C'$. In order to find out if there is an $s-t$ cut $(S, \Bar{S})$ with capacity at most $C$, we need to compare $C$ and $C'$. If $C' \leqslant C$, then our answer for \textbf{Decision} problem is "yes". If $C' > C$, then our answer for \textbf{Decision} problem is "no" because the capacity can never be less than $C'$. Since in $D$, we use $Opt(G)$ once and do a $\mathcal{O}(1)$ comparison, DECISION is polynomial time reducible to OPTIMIZATION 

\subsubsection*{2. OPTIMIZATION is polynomial time reducible to DECISION}
  
We can first find out the largest possible capacity $C^+$ by summing the capacity of all the positive edges. Similarly, we can find out the smallest possible capacity $C^-$ by summing the capacity of all edges with negative capacities. We can have an array to store the information for capacities from $C^-$ to $C^+$, which is $\mathcal{O}(n)$ with total $C^+-C^-+1$ elements. With starting index $0$ and ending index $C^+-C^-$. Then can implement binary-search-like algorithm to determine the smallest capacity. Notice that if we find a capacity value $C$ where $D(C)$ is true but $D(C-1)$ is false, we find the smallest capacity of any $s-t$ cut because no $s-t$ cut has lower capacity than $C$. 

\textbf{The running time:} Calculating $C^-$ and $C^+$ requires $\mathcal{O}(|E|)$. Notice that the running time is $\mathcal{O}(log n)$ for binary search. Since $C^++|C^-|+1 = \mathcal{O}(n)$, there are $\mathcal{O}(2^n)$ elements in terms of the number of bits. Therefore, the binary search which takes $\mathcal{O}(log{2^n}) = \mathcal{O}(n)$ is linear in terms of numbers of bit. Notice that the arithmetic operations in the algorithm take $\mathcal{O}(1)$, therefore the running time of this $Opt(G)$ with $D$ is weakly polynomial. [The algorithm is below]

\begin{proof}[Algorithm]{}
		\renewcommand{\qedsymbol}{}
		Algorithm $Opt(G)$ with "API" $D(G)$
		\begin{lstlisting}[basicstyle=\fontsize{8}{9}\selectfont\ttfamily]
~$G(V,E)$~ := input Graph  ~$s$~ := source node  ~$t$~ := tank node
~$D$~ := Decision Problem API  ~$C^-$~ := ~$\sum_{e\in E:c_e\leqslant 0 }c_e$~ ~$C^+$~ := ~$\sum_{e\in E:c_e>0 0 }c_e$~
int L = 0; int R = ~$|C^-|+C^+$~;
while(R>L){
    int M = L + (R-L)/2;
    if(D(M) == true) R = M;
    else L=M+1;
}
return R
		\end{lstlisting} 
\end{proof}

The algorithm aims to find the smallest $C$ where $D(C)$ is true. Similar to binary search, we strictly decrease the range of possible smallest $C$ on line 6 and 7 and keep searching on the range that contains the smallest $C$. Therefore the algorithm terminates whenever $R==L$, meaning the range now becomes one element. Thus, it always return the correct smallest $C$ S.T. $D(C)$ is true.

Therefore,   OPTIMIZATION is polynomial time reducible to DECISION.
Now that \textbf{Optimization problem} and \textbf{Decision problem} can be mutually polynomial-time reducible, they are polynomial-time equivalent.
\end{proof}

\subsection*{Problem b}
\begin{proof}{}{OPTIMIZATION-SEARCH polynomial-time equivalence}
    
\subsubsection*{1. OPTIMIZATION is polynomial time reducible to SEARCH}
Suppose $S(G)$ finds the min-cut $(S,\Bar{S})$ for the graph $G$ that minimizes $c(S,\Bar{S})$. By the definition of min-cut, the value of $c(S,\Bar{S})$ is already the smallest capacity value of any $s-t$ cut. Therefore, since in $Opt(G)$ we find min-cut $(S,\Bar{S})$ using $S(G)$ and calculate the capacity $c(S,\Bar{S})$ in $\mathcal{O}(|E|)$,  OPTIMIZATION is polynomial time reducible to SEARCH.

\subsubsection*{2. SEARCH is polynomial time reducible to OPTIMIZATION}
% \textbf{2. SEARCH is polynomial time reducible to OPTIMIZATION}

For graph $G$, $Opt(G)$ gives us the minimum cut capacities value for some to-be-discovered $s-t$ cut $(S, \Bar{S})$, denoted as $C$. Notice that it is possible that we have multiple minimum cuts with same capacities value. In the following discussion, the graph after operation of \texttt{set} $c_e = \infty$ or \texttt{construct an edge} $e(s,v)$ with capacity $c_e = \infty$ will be denoted as $G'$ for convenience. Also, the operation on edge $(s,v)$ refers to either make the capacity to $\infty$ or add a new edge with $\infty$ capacity for a vertex $v\in V, v\neq s, t$ for convenience.

\textbf{Observation:} Focusing on a cut $(S,\Bar{S})$ with capacity $Opt(G) = C$.

If a node $v\in S$, the operation on $(s,v)$ not change the capacity of $(S,\Bar{S})$. If a node $v \in \Bar{S}$, the operation increase the capacity of original cut $(S,\Bar{S})$ since the cut allows more flow to pass through, meaning the new cut for $(S,\Bar{S})$ will be larger than $C$. Thus, if the capacity of this cut become larger after the operation, $v \in \Bar{S}$ for this cut. Therefore, we can focus on the value of $Opt(G)$ which finds the min cut capacity of $G$ to find the actual min cut. To deal with multiple min cut candidates, keeping the infinite capacity edges (line 13-14) ensures that all future OPTIMIZATION are dependent on $(s,v)$ where $c_{(s,v)}=\infty$, so $v$ finds the nodes in the right cut. 

\begin{proof}[Algorithm]{}
		\renewcommand{\qedsymbol}{}
		Algorithm $S(G)$ with "API" $Opt(G)$
		\begin{lstlisting}[basicstyle=\fontsize{8}{9}\selectfont\ttfamily]
Inputs:
~$G(V,E)$~ := input Graph  ~$s$~ := source node  ~$t$~ := tank node
~$Opt$~ := Decision Problem API
Initializations:
~$S$~ = ~$\{s\}$~
~$\Bar{S}$~ = ~$\{t\}$~
~$C$~ = ~$Opt(G)$~
for each vertex ~$v\in V, v \neq s, v \neq t$~:
    if there exists and edge ~$e(s,v)$~:
        set ~$c_e = \infty$~
    else:
        construct an edge ~$e(s,v)$~ with capacity ~$c_e=\infty$~
    if(~$Opt(G)$~ == C): // min cut stays the same
        ~$S \leftarrow S \cup \{v\}$~
    else:
        ~$\Bar{S} \leftarrow \Bar{S} \cup \{v\}$~
        remove the newly added edge
return ~$(S, \Bar{S})$~
    
		\end{lstlisting} 
\end{proof}




(1) There exists a unique min cut $(S,\Bar{S})$ with capacity $C$ to SEARCH.

\qquad As observed above, if the $Opt(G')=Opt(G)$ after operation on $(s,v)$, we can say that $v\in S$ for that cut. If the cut capacity of $(S,\Bar{S})$ increases, $Opt(G) < Opt(G')$ because every other cut are strictly larger than original cut $(S,\Bar{S})$ and the cut capacity increase. Thus, we can say that $v \in \Bar{S}$ for the cut. Thus the output of $Opt(G)$ is the min cut $(S,\Bar{S})$.

(2) There exists multiple min $s-t$ cut candidates $(S_1,\Bar{S_1}), ... , (S_k,\Bar{S_k})$ to SEARCH. In this part of discussion, $i,j \in \{1,...,k\}, i\neq j, k \geqslant 1$. I'll discuss the correctness of algorithm in two situations.

\qquad For a node $v$ in $G$, if the operation on $(s,v)$ leads to $Opt(G') \geqslant Opt(G)$, we can say that $\forall (S_i, \Bar{S_i}): v \in \Bar{S_i}$ because the operation allows more flow to pass through all $k$ potential min cuts. Since $\forall (S_i, \Bar{S_i}): v\in \Bar{S_i}$, we add $v$ to $\Bar{S}$ (line 16). If the operation on $(s,v)$ doesn't change $Opt(G)$, this means that $v$ is in $S_i$ some other valid min cut $(S_i,\Bar{S_i})$. We add such $v$ to $S$ (line 14). By loop through all nodes (all cuts at the same time), we have $S = \bigcup_{i=1}^{k}S_i$ and $\Bar{S} = \bigcup_{i=1}^{k}\Bar{S_i}$. Therefore, by proving that the union of min cuts are still min cut we can prove our output $(S,\Bar{S})$ is a min cut.

\textbf{Corollary: } A cut $(X,\Bar{X})$ is minimal if and only if every maximal flow $f$ saturates all arcs of $(X,\Bar{X})$ whereas all arcs of $(X,\Bar{X})$ are flowless with respect to f. [As discussed in lecture and stated by Ford and Fulkerson]

\qquad Therefore, for two min cuts $(S_i,\Bar{S_i})$ and $(S_j, \Bar{S_j})$, we can prove that their union is still a min cut. Every outflow edge from $S_i$ and $S_j$ is filled. Therefore, every outflow edge from $S_i \cup S_j$ comes from $S_i$ or $S_j$. Since min cut $\Leftrightarrow$ edges crossing the cut are filled, $(S_i \cup S_j, \Bar{S_i} \cup \Bar{S_j})$ is also a min cut. Therefore, $(S,\Bar{S}) = (\bigcup_{i=1}^{k}{S_i},\bigcup_{i=1}^{k}\Bar{S_i})$ is also the min cut. This proves that the output of $S(G)$ with "API" $Opt(G)$ is indeed the min cut.

Since we call $Opt(G)$ API $\mathcal{O}(|E|)$ times, we can say that SEARCH is polynomial time reducible to OPTIMIZATION. Now that OPTIMIZATION is also polynomial time reducible to SEARCH, we concludes that OPTIMIZATION and SEARCH are polynomial-equivalent.


\end{proof}


\section*{Problem2}
\subsubsection*{Problem a}
In the same scenario, we can convert the problem into a "natural" decision problem: "Is there an assignment of $n$ students to $k$ teams S.T. each team has $n/k$ students and the skill difference between most skilled team and least skilled team is at most $\Delta$" 

\textbf{Certificate:} an classroom of $n$ people, a collection/assignment of $k$ teams (each with $n/k$ people), each with student has $s_i$ integer skill value. ($\mathcal{O}(n)$ linear)

\textbf{Certifier:} check if this is the correct collection of $k$ teams, calculate the skill difference $\mathbf{\max}-\mathbf{\min}$ between the maximum team and the minimum team, and compare it with $\Delta$.

The certifier of this problem needs (1) calculate the total score for each team, it requires $\mathcal{O}(n)$ for looping all $n$ students. (2) loop through all $k$ groups and store the $\mathbf{\max}$ and $\mathbf{\min}$ in $\mathcal{O}(k)$ (3) compute the difference $\mathbf{\max} - \mathbf{\min}$ (4) then compare $\Delta$ with the skill difference. If $\Delta < \mathbf{\max} - \mathbf{\min}$, output "no", else "yes". Since the certifier requires $\mathcal{O}(n+k)$, and comparison between two integers is easy, the converted decision problem is in \textbf{NP}.

\subsubsection*{Problem b}
In the same scenario, we can convert the problem into a "natural" decision problem: "given $k$ partitions $(S_i, \Bar{S_i}), i = 1, . . . , k$ of nodes, and a cut capacity bound $C \geqslant 0$, is there a way to get a set $E$ of undirected edges S.T. for all partitions the max number of crossing edges $\leqslant C$ and $|E| \geqslant L$, where $L\geqslant 0$ is an integer.

\textbf{Certificate:} a set $E$ of undirected edges on $G$. ($\mathcal{O}(|V|^2)$ polynomial)

\textbf{Certifier:} check if for all partitions $(S_i,\Bar{S_i})$ the number of edges it partitions in $G=(V,E)$ is at most $C$ and $|E|$ is at least $L$

The certifier of this problem needs (1) loop through all $k$ possible partitions, it requires $\mathcal{O}(k)$ times of iterations (2) check the number of edges crossing for each partition $(S_i, \Bar{S_i})$ ($u \in S_i, v_\in \Bar{S_i}, (u,v)$), each of which requires $\mathcal{O}(|E|)$. Since the certifier requires $\mathcal{O}(k|E|)$, and the comparison between two values. If all partitions has less than $C$ edges then "yes" else "no". The converted decision problem is in \textbf{NP}.

\section*{Problem3}

\textbf{(a)}
Given an integer $C$, is there a way to move all boxes from their start positions to the desired end position in at most $C$ steps?

\textbf{(b)}
A proposed sequence of move

\textbf{(c)}
(1) check whether or not the steps of move $\leqslant C$

(2)  Follow the sequence of move, check whether or not all boxes are put into the end position.

\textbf{(d)}
The size of certificate (the steps of move) is not necessarily polynomial. It could be exponential. Therefore, this may not satisfy the definition of NP problem. As discussed in lectures: if the correct answer for $x$ is "Yes", then there exists a $y$ (called "certificate") of length at most $|y| \leqslant r(|x|)$ such that $B(x,y)$ answers "Yes". Nevertheless, a sequence of move (certificate) is not necessarily bounded by polynomial time with respect to the size of board. Thus, it isn't sufficient to show SOKOBAN is in NP.


\section*{Problem4}
\subsection*{Problem a}

\textbf{Certificate:} $(P, \hat{x}, \hat{t}, \hat{z})$ and binary string $y$

\textbf{Certifier:} 

(1) check whether or not $|y| \leqslant |\hat{z}|$

(2) check whether or not $P(\hat{x},y)$ terminates in $|\hat{t}|$ steps


(3) run $P(\hat{x},y)$ for $|\hat{t}|$ steps. If $P(\hat{x},y)$ terminates in $|\hat{t}|$ steps, output $P(\hat{x},y)$. Else, output "no"

Therefore we show that CERTIFICATION is in NP.

\subsection*{Problem b}

\begin{proof}{CERTIFICATION is NP-complete}

Every problem in NP $\leqslant_p$ CERTIFICATION. We need to build a reduction $f$ from $X \in NP$ to CERTIFICATION.

Since $X\in NP$, we have a efficient certifier $B(x,y)$ that terminates in $q(|x|+|y|)$ steps, where $|y| \leqslant r(|x|)$ ($q, r$ are some polynomial functions), $x$ is some input, and $y$ is a certificate in polynomial size.

Input: A problem $X\in NP$.

Output: $(P, \hat{x}, \hat{t}, \hat{z})$.

\qquad $\hat{z}$ is a binary string of length $r(|x|)$.

\qquad $\hat{t}$ is a binary string of length $q(|x|+|y|)$.

\qquad $\hat{x} = x$. $P=B$.

Therefore, we have $(B, x, \hat{t}, \hat{z})$ as output. Then, call CERTIFICATION$(B, x, \hat{t}, \hat{z})$ to find if there exists a certificate $y$ that is polynomial in length of input $x$ to $X$ S.T. the certifier $B$ for $X\in NP$ return "Yes" in at most $|\hat{t}|=q(|x|+|y|)$ times. This concludes the reduction.

For a reduction function $f$, it needs to satisfy the following:

 1. "Yes" instances map to "Yes" instances.

\qquad If correct answer for $x$ is "Yes" (there is a $y$ S.T. $|y|\leqslant r(|x|)$ and $B(x,y)$ return "Yes"), then $P(\hat{x},y)$ returns "Yes".

 2. "No" instances map to "No" instances.

\qquad If correct answer for $x$ is "No" (there is no such a $y$ S.T. $B(x,y)$ returns "Yes), then $P(\hat{x},y)$ returns "No".

3. $f$ runs in polynomial time.

Here are proofs for properties listed above:

\qquad 1: If correct answer for $x$ is "Yes", then there is a binary string $y$ of length at most $|y| \leqslant r(|x|) = |\hat{z}|$ S.T. $B(x,y)$ return "Yes" in $|\hat{t}| = q(|x|+|y|)$ steps [definition of NP discussed in lectures]. Therefore correct answer for $(B, x, \hat{t}, \hat{z})$ is "Yes" now that $P(\hat{x},y) = B(x,y)$ terminates in $|\hat{t}| = q(|x|+|y|)$ steps.

\qquad 2: If the correct answer for $x$ is "no", then there is no binary string $y$ of length at most $|\hat{z}|$ S.T. $B(x,y)$ returns "yes" in at most $|\hat{t}|$ steps. Since there is no such a binary string $y$ that makes $P(\hat{x},y) = B(x,y)$ return "Yes, "No" is the correct answer for $(B,x,\hat{t},\hat{z})$


\qquad 3: $|$binary string$|$ is polynomial in length. Adding $B$ takes $\mathcal{O}(1)$ time. Therefore, $f$ runs in polynomial time.

Therefore, it suffices to say that $X\in NP, X \leqslant_p$ CERTIFICATION






    
\end{proof}


\end{document}
